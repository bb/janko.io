<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Resumable File Uploads in Ruby | Janko's Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Resumable File Uploads in Ruby" />
<meta name="author" content="Janko Marohnić" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I recently released tus-ruby-server, a Ruby server implementation for tus, an open protocol for resumable file uploads built on HTTP." />
<meta property="og:description" content="I recently released tus-ruby-server, a Ruby server implementation for tus, an open protocol for resumable file uploads built on HTTP." />
<link rel="canonical" href="https://janko.io/resumable-file-uploads-in-ruby/" />
<meta property="og:url" content="https://janko.io/resumable-file-uploads-in-ruby/" />
<meta property="og:site_name" content="Janko’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-09-04T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Resumable File Uploads in Ruby" />
<meta name="twitter:site" content="@jankomarohnic" />
<meta name="twitter:creator" content="@jankomarohnic" />
<meta property="article:publisher" content="https://www.facebook.com/janko.marohnic/" />
<script type="application/ld+json">
{"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://janko.io/images/logo.png"},"name":"Janko Marohnić"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://janko.io/resumable-file-uploads-in-ruby/"},"author":{"@type":"Person","name":"Janko Marohnić"},"headline":"Resumable File Uploads in Ruby","dateModified":"2016-09-04T00:00:00+02:00","description":"I recently released tus-ruby-server, a Ruby server implementation for tus, an open protocol for resumable file uploads built on HTTP.","datePublished":"2016-09-04T00:00:00+02:00","url":"https://janko.io/resumable-file-uploads-in-ruby/","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link type="application/atom+xml" rel="alternate" href="https://janko.io/feed.xml" title="Janko's Blog" />
    <link rel="stylesheet" href="/css/bundle.css">
  </head>

  <body class="text-xl text-gray-700">
    <header class="py-3 px-4 flex flex-col space-y-1 bg-gray-100 border-b">
      <div class="flex justify-center">
        <a class="flex items-center space-x-2" href="/">
          <img class="h-8" src="/images/logo.png" alt="logo" />
          <span class="text-2xl md:text-3xl font-semibold text-pink-700">Janko's Blog</span>
        </a>
      </div>
      <div class="flex justify-center">
        <span class="text-base md:text-lg text-gray-500">Sharing the wonders of Ruby</p>
      </div>
    </header>

    <div class="my-6 sm:my-8 mx-3">
      <main class="max-w-screen-sm md:max-w-screen-md mx-auto">
        <article>
  <header class="space-y-4 md:space-y-5">
    <h1 class="lg:-mx-28 text-3xl sm:text-4xl lg:text-5xl text-center font-medium text-gray-900">Resumable File Uploads in Ruby</h1>

    <div class="flex justify-center">
      <div class="flex flex-col items-center sm:flex-row sm:items-baseline space-y-3 sm:space-y-0 sm:space-x-4 text-sm md:text-base">
        <span class="text-gray-500">
          By <a class="underline hover:text-gray-700" href="/about">Janko Marohnić</a> on
          <time datetime="2016-09-04 00:00:00 +0200">
            04 Sep 2016
          </time>
        </span>
        
          <a class="rounded-full px-3 bg-pink-100 text-pink-800 font-semibold py-0.5" href="/shrine">shrine</a>
        
      </div>
    </div>
  </header>

  <div class="mt-4 sm:mt-6 prose md:prose-xl">
    <p>I recently released <a href="https://github.com/janko/tus-ruby-server">tus-ruby-server</a>, a Ruby server implementation for <a href="http://tus.io/">tus</a>,
an open protocol for resumable file uploads built on HTTP.</p>

<h2 id="protocol">Protocol</h2>

<p>Let’s first briefly explain what is tus. Tus is a <a href="http://tus.io/protocols/resumable-upload.html">specification</a> that
describes the communication between the client and the server through HTTP for
achieving reliable and resumable file uploads, even on unstable networks. Check
out the <a href="http://tus.io/demo.html">demo</a>.</p>

<p>“Resumable upload” doesn’t mean giving your user a button to resume the upload
whenever there is a network hiccup. It means having the client automatically
reinitiate interrupted uploads without the user knowing about it. Tus enables
resuming the upload even after the user closes the browser or shuts down the
device, as long as the user selects the same file.</p>

<p>Tus was created by <a href="https://transloadit.com/">Transloadit</a>, and has received feedback from well-known
companies like Vimeo, Google and GitHub.</p>

<h2 id="implementations">Implementations</h2>

<p>There are many client-side implementations, including <a href="https://github.com/tus/tus-js-client">JavaScript</a>,
<a href="https://github.com/tus/TUSKit">iOS</a> and <a href="https://github.com/tus/tus-android-client">Android</a>, as well as server-side
implementations, covering <a href="https://github.com/tus/tusd">Go</a>, <a href="https://github.com/tus/tus-node-server">Node.js</a>, <a href="https://github.com/matthoskins1980/Flask-Tus">Python</a>, <a href="https://github.com/terrischwartz/tus_servlet">Java</a>, <a href="https://github.com/leblanc-simon/php-tus">PHP</a>, <a href="https://github.com/smatsson/tusdotnet">.NET</a> and
others.</p>

<p>There already is an existing Ruby server implementation, <a href="https://github.com/picocandy/rubytus">Rubytus</a>. However,
there are two main reasons why I decided to write my own:</p>

<p>One reason is that at the time of this writing Rubytus supported an older
version of the protocol. When I attempted to bring it to tus 1.0, I realized
that many things have changed since that version.</p>

<p>Another reason is that it’s written in a non-standard web framework, <a href="https://github.com/postrank-labs/goliath">Goliath</a>.
Goliath is a non-blocking Ruby web framework built on top of <a href="https://github.com/eventmachine/eventmachine">EventMachine</a>. I
think Goliath is great when you want to scale apps that do a lot of IO (like
database writing and HTTP requests), but here we’re just writing files to the
filesystem. And while Goliath definitely has a nice callback-less API, you
still have to be aware that you’re writing asynchronous code, which made it
difficult for me to precisely implement the protocol.</p>

<h2 id="ruby-server">Ruby server</h2>

<p>The <a href="https://github.com/janko/tus-ruby-server">tus-ruby-server</a> fully implements the tus protocol with all its
extensions, and it’s written in <a href="https://github.com/jeremyevans/roda">Roda</a>, for me the best web framework for
writing APIs. With Roda you can route and handle requests in a very linear and
DRY way, which allowed me to precisely follow the specification and return the
appropriate status and HTTP headers for various situations.</p>

<p>But from the developer’s perspective, <a href="https://github.com/janko/tus-ruby-server">tus-ruby-server</a> is just a Rack app
which you can run standalone or as part of your app:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Gemfile</span>
<span class="n">gem</span> <span class="s2">"tus-server"</span>
</code></pre></div></div>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config.ru</span>
<span class="nb">require</span> <span class="s2">"tus/server"</span>

<span class="n">map</span> <span class="s2">"/files"</span> <span class="k">do</span>
  <span class="n">run</span> <span class="no">Tus</span><span class="o">::</span><span class="no">Server</span>
<span class="k">end</span>
</code></pre></div></div>

<p>On the client-side you can now use <a href="https://github.com/tus/tus-js-client">tus-js-client</a> to listen on file select,
and initiate a tus upload to the endpoint.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fileInput</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">change</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">file</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">files</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

  <span class="kd">var</span> <span class="nx">upload</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">tus</span><span class="p">.</span><span class="nx">Upload</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">endpoint</span><span class="p">:</span>  <span class="dl">"</span><span class="s2">http://localhost:9292/files/</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">chunkSize</span><span class="p">:</span> <span class="mi">15</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span> <span class="c1">// 15MB</span>
  <span class="p">});</span>

  <span class="nx">upload</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></div></div>

<p>After upload is complete you will get a URL to the uploaded file, and you’ll
probably want to attach it to a database record. <a href="https://github.com/shrinerb/shrine">Shrine</a> is one file
attachment library that supports attaching by custom URLs using <a href="https://github.com/shrinerb/shrine-url">shrine-url</a>,
see <a href="https://github.com/shrinerb/shrine-tus-demo">shrine-tus-demo</a> on how you can integrate these.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://localhost:9292/files/ebfe84d3921ce31fe603c6a9ae5f81b8
</code></pre></div></div>

<p>Other popular file attachment libraries like CarrierWave, Paperclip, Refile or
Dragonfly also support attaching remote files via URLs, but they will also
automatically download the file. This is not really feasible here, because
these files will typically be fairly large (that’s why we’re using this
protocol in the first place).</p>

<p>Shrine allows you to save only the URL, and spawn a background job which will
upload this file to a storage of your choice. This keeps the form submission
instantaneous.</p>

<p>Ok, now that we got the integration out of the way, I thought it would be
interesting to go over some parts of the tus protocol, to see how it can
improve the general user experience around file uploads.</p>

<h3 id="uploading">Uploading</h3>

<p>Tus enables file data to be sent in multiple PATCH requests:</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">PATCH</span> <span class="nn">/files/{uid}</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/offset+octet-stream</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">30</span>
<span class="na">Upload-Offset</span><span class="p">:</span> <span class="s">0</span>
<span class="na">Tus-Resumable</span><span class="p">:</span> <span class="s">1.0.0</span>

[ first 30 bytes ]
</code></pre></div></div>
<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">PATCH</span> <span class="nn">/files/{uid}</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/offset+octet-stream</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">70</span>
<span class="na">Upload-Offset</span><span class="p">:</span> <span class="s">30</span>
<span class="na">Tus-Resumable</span><span class="p">:</span> <span class="s">1.0.0</span>

[ next 70 bytes ]
</code></pre></div></div>

<p>The interesting header here is <code class="language-plaintext highlighter-rouge">Upload-Offset</code>, which allows the client to
continue sending more data to an existing upload. This means the client can
split large files into multiple chunks, and repeat PATCH requests that failed
due to network issues.</p>

<h3 id="concatenation">Concatenation</h3>

<p>In addition to appending to an existing upload, the protocol also supports
uploading the chunks individually, and then concatenating them into a single
file. This allows the client to upload multiple chunks in parallel, which
can provide a significant overall speedup:</p>

<blockquote>
  <p>[…] on our internal network, sending a 110 MB file to S3 with chunk sizes of 5 MB took about 22 seconds when chunks were uploaded one-at-a-time (with concurrent chunking disabled). When maxing out the default maxConnections for that file (3 chunks at once, concurrent chunking enabled) the same file uploaded in about 12 seconds.</p>

  <p>— Ray Nicholus, creator of <a href="http://fineuploader.com/">FineUploader</a></p>
</blockquote>

<p>We could for example upload two chunks:</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">PATCH</span> <span class="nn">/files/a</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Upload-Concat</span><span class="p">:</span> <span class="s">partial</span>
<span class="na">Upload-Offset</span><span class="p">:</span> <span class="s">0</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">5</span>

hello
</code></pre></div></div>
<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">PATCH</span> <span class="nn">/files/b</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Upload-Concat</span><span class="p">:</span> <span class="s">partial</span>
<span class="na">Upload-Offset</span><span class="p">:</span> <span class="s">0</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">6</span>

 world
</code></pre></div></div>

<p>And then concatenate them into a single file:</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">POST</span> <span class="nn">/files</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Upload-Concat</span><span class="p">:</span> <span class="s">final;/files/a /files/b</span>
</code></pre></div></div>
<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">201</span> <span class="ne">Created</span>
<span class="na">Location</span><span class="p">:</span> <span class="s">/files/ab</span>
</code></pre></div></div>

<p>The length of the final resource is now 11 bytes consisting of <code class="language-plaintext highlighter-rouge">hello world</code>:</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">HEAD</span> <span class="nn">/files/ab</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
</code></pre></div></div>
<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">OK</span>
<span class="na">Upload-Length</span><span class="p">:</span> <span class="s">11</span>
<span class="na">Upload-Concat</span><span class="p">:</span> <span class="s">final;/files/a /files/b</span>
</code></pre></div></div>

<h3 id="checksum">Checksum</h3>

<p>Networks are not reliable, and sometimes <a href="https://github.com/tus/tus-resumable-upload-protocol/issues/7#issuecomment-16568773">bytes can get lost</a>. That’s why tus
allows the client to send a checksum of the data it’s sending.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">PATCH</span> <span class="nn">/files/{uid}</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">11</span>
<span class="na">Upload-Offset</span><span class="p">:</span> <span class="s">0</span>
<span class="na">Upload-Checksum</span><span class="p">:</span> <span class="s">sha1 Kq5sNclPz7QV2+lfQIuc6R7oRu0=</span>

hello world
</code></pre></div></div>

<p>When server receives the data, it too can generate a checksum of the received
data using the same algorithm, and verify that it matches the received one.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">204</span> <span class="ne">No Content</span>
<span class="na">Upload-Offset</span><span class="p">:</span> <span class="s">11</span>
</code></pre></div></div>

<h3 id="termination">Termination</h3>

<p>In addition to resuming, with tus you can also give users the ability to
terminate uploads, which deletes the data that was uploaded up to that point.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">DELETE</span> <span class="nn">/files/{uid}</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
</code></pre></div></div>

<h3 id="storage">Storage</h3>

<p>The tus-ruby-server implementation by default stores uploaded files on the
filesystem. However, the downside of storing files on the filesystem is that
it isn’t distributed, so for the resumable uploads to work you would have to
host tus-ruby-server on a single server.</p>

<p>That might or might not be a bottleneck, depending on the rate of file uploads
you’re accepting. Alternatively you can choose the Mongo <a href="https://docs.mongodb.org/v3.0/core/gridfs/">GridFS</a> storage,
which among other things is convenient for multi-server setup.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"tus/server"</span>
<span class="nb">require</span> <span class="s2">"tus/storage/gridfs"</span> <span class="c1"># requires the "mongo" gem</span>

<span class="n">client</span> <span class="o">=</span> <span class="no">Mongo</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"mongodb://127.0.0.1:27017/mydb"</span><span class="p">)</span>
<span class="no">Tus</span><span class="o">::</span><span class="no">Server</span><span class="p">.</span><span class="nf">opts</span><span class="p">[</span><span class="ss">:storage</span><span class="p">]</span> <span class="o">=</span> <span class="no">Tus</span><span class="o">::</span><span class="no">Storage</span><span class="o">::</span><span class="no">Gridfs</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">client: </span><span class="n">client</span><span class="p">)</span>
</code></pre></div></div>

<p>You can also write your own storage which implements the same interface as
<a href="https://github.com/janko/tus-ruby-server/blob/master/lib/tus/storage/filesystem.rb"><code class="language-plaintext highlighter-rouge">Tus::Storage::Filesystem</code></a> and <a href="https://github.com/janko/tus-ruby-server/blob/master/lib/tus/storage/gridfs.rb"><code class="language-plaintext highlighter-rouge">Tus::Storage::Gridfs</code></a>.</p>

<h2 id="limitations">Limitations</h2>

<p>One advantage of Rubytus is that the Goliath web framework is able to handle
interrupted PATCH requests, by saving all the data it has received before the
HTTP connection was closed.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Code is from https://github.com/picocandy/rubytus</span>

<span class="k">class</span> <span class="nc">TusServer</span> <span class="o">&lt;</span> <span class="no">Goliath</span><span class="o">::</span><span class="no">API</span>
  <span class="c1"># executed when headers are received</span>
  <span class="k">def</span> <span class="nf">on_headers</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>

  <span class="c1"># executed whenever part of the body is received</span>
  <span class="k">def</span> <span class="nf">on_body</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">env</span><span class="p">[</span><span class="s2">"REQUEST_METHOD"</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"PATCH"</span>
      <span class="n">env</span><span class="p">[</span><span class="s2">"api.buffers"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="c1"># save the received data</span>
    <span class="k">else</span>
      <span class="n">env</span><span class="p">[</span><span class="s2">"rack.input"</span><span class="p">]</span> <span class="o">=</span> <span class="no">StringIO</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># default behaviour</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># executed when the connection is closed (either completed or interrupted)</span>
  <span class="k">def</span> <span class="nf">on_close</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">env</span><span class="p">[</span><span class="s2">"REQUEST_METHOD"</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"PATCH"</span>
      <span class="n">storage</span><span class="p">.</span><span class="nf">patch_file</span><span class="p">(</span><span class="n">env</span><span class="p">[</span><span class="s2">"api.uid"</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="s2">"api.buffers"</span><span class="p">])</span> <span class="c1"># store the received data</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Tus-ruby-server is implemented in Roda, which is built on top of Rack (like most
other web frameworks), and from research that I performed, web servers for Rack
applications don’t have a configuration option for forwarding interrupted
requests to the app.</p>

<p>By default tus-js-client will use only a single PATCH request to upload the
whole file, and send additional ones if the connection gets interrupted. So you
just need to configure tus-js-client or whichever client library you’re using
to upload in multiple chunks. This way if the connection gets interrupted, all
previously uploaded chunks will remain on the server.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nx">tus</span><span class="p">.</span><span class="nx">Upload</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">endpoint</span><span class="p">:</span>  <span class="dl">"</span><span class="s2">http://localhost:9292/files/</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">chunkSize</span><span class="p">:</span> <span class="mi">15</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span> <span class="c1">// 15MB</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Since chunked uploads can even significantly speed up the general upload if you
use parallelization, not being able to resume an upload of a single PATCH
request practically shouldn’t be a significant limitation.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I’m really excited that, rather than each company implementing their own
protocol, we now have an open stable resumable upload protocol which we can all
agree on, and build generic client and server libraries which everyone can use.</p>

<p>With <a href="https://github.com/janko/tus-ruby-server">tus-ruby-server</a> and <a href="https://github.com/shrinerb/shrine">Shrine</a> on the server, and
<a href="https://github.com/tus/tus-js-client">tus-js-client</a> / <a href="https://github.com/tus/TUSKit">TUSKit</a> / <a href="https://github.com/tus/tus-android-client">tus-android-client</a> on the client, anyone can now add
resumable file uploads to their Ruby applications.</p>


  </div>
</article>

<div class="mt-8 md:mt-10">
  
  <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'twinblog'; // required: replace example with your forum shortname
    var disqus_identifier = '/resumable-file-uploads-in-ruby';
    var disqus_url = 'https://janko.io/resumable-file-uploads-in-ruby/';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



</div>

      </main>
    </div>

    
      <script>
  // Gauges
  var _gauges = _gauges || [];
  (function() {
    var t   = document.createElement('script');
    t.type  = 'text/javascript';
    t.async = true;
    t.id    = 'gauges-tracker';
    t.setAttribute('data-site-id', '51f5bd47f5a1f545ac0000fc');
    t.src = '//secure.gaug.es/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>

    
  </body>
</html>
