<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>The Complexity of Active Record Transactions | Janko's Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="The Complexity of Active Record Transactions" />
<meta name="author" content="Janko Marohnić" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I’ve recently picked up the sequel-activerecord_connection gem again to make some reliability improvements around database transactions. For context, this gem extends Sequel with the ability to reuse Active Record’s database connection, which should lower the barrier for trying out Sequel in apps that use Active Record." />
<meta property="og:description" content="I’ve recently picked up the sequel-activerecord_connection gem again to make some reliability improvements around database transactions. For context, this gem extends Sequel with the ability to reuse Active Record’s database connection, which should lower the barrier for trying out Sequel in apps that use Active Record." />
<link rel="canonical" href="https://janko.io/the-complexity-of-activerecord-transactions/" />
<meta property="og:url" content="https://janko.io/the-complexity-of-activerecord-transactions/" />
<meta property="og:site_name" content="Janko’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-09-28T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="The Complexity of Active Record Transactions" />
<meta name="twitter:site" content="@jankomarohnic" />
<meta name="twitter:creator" content="@jankomarohnic" />
<meta property="article:publisher" content="https://www.facebook.com/janko.marohnic/" />
<script type="application/ld+json">
{"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://janko.io/images/logo.png"},"name":"Janko Marohnić"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://janko.io/the-complexity-of-activerecord-transactions/"},"author":{"@type":"Person","name":"Janko Marohnić"},"headline":"The Complexity of Active Record Transactions","dateModified":"2020-09-28T00:00:00+02:00","description":"I’ve recently picked up the sequel-activerecord_connection gem again to make some reliability improvements around database transactions. For context, this gem extends Sequel with the ability to reuse Active Record’s database connection, which should lower the barrier for trying out Sequel in apps that use Active Record.","datePublished":"2020-09-28T00:00:00+02:00","url":"https://janko.io/the-complexity-of-activerecord-transactions/","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link type="application/atom+xml" rel="alternate" href="https://janko.io/feed.xml" title="Janko's Blog" />
    <link rel="stylesheet" href="/css/bundle.css">
  </head>

  <body class="text-xl text-gray-700">
    <header class="py-3 px-4 flex flex-col space-y-1 bg-gray-100 border-b">
      <div class="flex justify-center">
        <a class="flex items-center space-x-2" href="/">
          <img class="h-8" src="/images/logo.png" alt="logo">
          <span class="text-2xl md:text-3xl font-semibold text-pink-700">Janko's Blog</span>
        </a>
      </div>
      <div class="flex justify-center">
        <span class="text-base md:text-lg text-gray-500">Sharing the wonders of Ruby
      </span>
</div>
    </header>

    <div class="my-6 sm:my-8 mx-4">
      <main class="max-w-screen-sm md:max-w-screen-md mx-auto">
        <article>
  <header class="space-y-4 md:space-y-5">
    <h1 class="lg:-mx-28 text-3xl sm:text-4xl lg:text-5xl text-center font-medium text-gray-900">The Complexity of Active Record Transactions</h1>

    <div class="flex justify-center">
      <div class="flex flex-col items-center sm:flex-row sm:items-baseline space-y-3 sm:space-y-0 sm:space-x-4 text-sm md:text-base">
        <span class="text-gray-500">
          By <a class="underline hover:text-gray-700" href="/about">Janko Marohnić</a> on
          <time datetime="2020-09-28 00:00:00 +0200">
            28 Sep 2020
          </time>
        </span>
        
          <a class="rounded-full px-3 bg-pink-100 text-pink-800 font-semibold py-0.5" href="/sequel">sequel</a>
        
      </div>
    </div>
  </header>

  <div class="mt-4 sm:mt-6 prose md:prose-xl">
    <p>I’ve recently picked up the <a href="https://github.com/janko/sequel-activerecord_connection">sequel-activerecord_connection</a> gem again to make
some reliability improvements around database transactions. For context, this
gem extends <a href="https://github.com/jeremyevans/sequel">Sequel</a> with the ability to reuse Active Record’s database
connection, which should lower the barrier for trying out Sequel in apps that
use Active Record.</p>

<p>After <a href="https://github.com/janko/sequel-activerecord_connection/commit/a30953269cbe4bc764b055e33efb2a4acff977e2">pushing some fixes</a>, I was thinking how working on
this gem has greatly increased my familiarity with the internals of database
transaction implementations of both Active Record and Sequel. Since there
aren’t any existing articles on this topic, I thought it would be useful to
share the knowledge I gathered over the past few months.</p>

<p>This article will compare the transaction API implementation between Active
Record and Sequel, and assumes the reader is already familiar with Active
Record’s transaction API usage. As the title suggests, I will be critical of
Active Record’s implementation. I know some will perceive this as “not nice”,
but I think it’s important to be aware of the internal complexity of libraries
we’re using every day (myself included).</p>

<h2 id="model-vs-database">Model vs Database</h2>

<h3 id="active-record">Active Record</h3>

<p>Active Record transactions are typically called on the model, which is shown in
the <a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html">official docs</a> as well. I think this can be
misleading to novice developers, as it suggests that database transactions are
tied to specific database tables, when in fact they’re applied to any queries
made by the current database connection.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># opens a connection-wide transaction (unrelated to the `accounts` table)</span>
<span class="no">Account</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
  <span class="n">balance</span><span class="p">.</span><span class="nf">save!</span>
  <span class="n">account</span><span class="p">.</span><span class="nf">save!</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Active Record provides transaction callbacks as part of a model’s lifecycle,
allowing you to execute code after the transaction commits or rolls back. This,
for example, allows you to spawn a background job after a record is persisted,
but wait until the transaction commits to ensure the record is up-to-date when
the background job is picked up.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Account</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">after_create_commit</span> <span class="ss">:send_welcome_email</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">send_welcome_email</span>
    <span class="no">AccountMailer</span><span class="p">.</span><span class="nf">welcome</span><span class="p">(</span><span class="nb">self</span><span class="p">).</span><span class="nf">deliver_later</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In my opinion, this approach has several issues. For one, it encourages putting
business logic into your Active Record models, and generally increases
complexity of the model lifecycle. It’s unfortunately not trivial to use
transaction callbacks <em>outside</em> of models, because they’re <a href="https://github.com/rails/rails/blob/f40c17dcfafa57bcbd8fd2ff6745f37334ba78d9/activerecord/lib/active_record/connection_adapters/abstract/transaction.rb#L137-L154">coupled to
models</a> (although there are
<a href="https://github.com/Envek/after_commit_everywhere">gems</a> that work around that).</p>

<p>Transaction callbacks can also negatively impact memory usage if you’re
allocating many model instances within a transaction, as references to these
model instances are held until the transaction is committed or rolled back,
which prevents Ruby from garbage collecting them beforehand. Active Record will
do this for any model that has any transaction callbacks defined.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Comment</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">after_commit</span> <span class="ss">:deliver_new_mentions</span><span class="p">,</span> <span class="ss">on: </span><span class="p">[</span><span class="ss">:create</span><span class="p">,</span> <span class="ss">:update</span><span class="p">],</span> <span class="ss">if: :body_changed?</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">deliver_new_mentions</span>
    <span class="no">MentionNotificationJob</span><span class="p">.</span><span class="nf">deliver_later</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
  <span class="n">author</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">find_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">comment</span><span class="o">|</span>
    <span class="c1"># Even though we're not triggering the `after_commit` callback here, Active</span>
    <span class="c1"># Record will still keep references to these model instances, preventing</span>
    <span class="c1"># Ruby from garbage collecting them until the transaction is closed.</span>
    <span class="n">comment</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="ss">author: </span><span class="n">new_author</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="sequel">Sequel</h3>

<p>In Sequel, the transaction API is implemented on the database object, which is
completely decoupled from models.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">DB</span> <span class="o">=</span> <span class="no">Sequel</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="ss">adapter: </span><span class="s2">"postgresql"</span><span class="p">,</span> <span class="ss">database: </span><span class="s2">"myapp"</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;Sequel::Database ...&gt;</span>
</code></pre></div></div>
<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># calling #transaction on the database object communicates it's connection-wide</span>
<span class="no">DB</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
  <span class="n">balance</span><span class="p">.</span><span class="nf">save</span>
  <span class="n">account</span><span class="p">.</span><span class="nf">save</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Sequel also has transaction hooks, but they too are defined on the database
object, and aren’t tied to models in any way – they’re just blocks of code that
get executed after the transaction is committed or rolled back. This makes them
possible to use in business logic that lives outside of models (of course, in
that case one can also just move the code outside of the transaction block).</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CreateAccount</span>
  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="no">DB</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
      <span class="n">account</span> <span class="o">=</span> <span class="no">Account</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
      <span class="n">send_welcome_email</span><span class="p">(</span><span class="n">account</span><span class="p">)</span>
      <span class="n">account</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="ss">api_key: </span><span class="no">SecureRandom</span><span class="p">.</span><span class="nf">hex</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">send_welcome_email</span><span class="p">(</span><span class="n">account</span><span class="p">)</span>
    <span class="c1"># queue email delivery after the enclosing transaction commits</span>
    <span class="no">DB</span><span class="p">.</span><span class="nf">after_commit</span> <span class="k">do</span>
      <span class="no">AccountMailer</span><span class="p">.</span><span class="nf">welcome</span><span class="p">(</span><span class="n">account</span><span class="p">).</span><span class="nf">deliver_later</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And if you really want to register transaction hooks on the model level, you
can do that inside regular model lifecycle hooks:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Account</span> <span class="o">&lt;</span> <span class="no">Sequel</span><span class="o">::</span><span class="no">Model</span>
  <span class="k">def</span> <span class="nf">after_create</span>
    <span class="n">db</span><span class="p">.</span><span class="nf">after_commit</span> <span class="p">{</span> <span class="no">AccountMailer</span><span class="p">.</span><span class="nf">welcome</span><span class="p">(</span><span class="nb">self</span><span class="p">).</span><span class="nf">deliver_later</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>By giving us the ability to compose APIs this way, the <code class="language-plaintext highlighter-rouge">Sequel::Model</code> class
was able to remain unaware of the existence of transaction hooks (which keeps
it simpler), but we were still able to achieve the same functionality as we
have with Active Record.</p>

<p>Note that the examples above will still keep references to the model instances
until the transaction is closed. However, Sequel’s API gives us the necessary
control to change that. For example, we can choose to register a transaction
hook only if a certain condition holds (useful in use cases like <a href="https://github.com/shrinerb/shrine/commit/08ed806110139b83401f603ac95cea5d6abf7bd2">file
attachments</a>):</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Comment</span> <span class="o">&lt;</span> <span class="no">Sequel</span><span class="o">::</span><span class="no">Model</span>
  <span class="k">def</span> <span class="nf">after_save</span>
    <span class="k">if</span> <span class="n">column_changed?</span><span class="p">(</span><span class="ss">:body</span><span class="p">)</span>
      <span class="n">db</span><span class="p">.</span><span class="nf">after_commit</span> <span class="p">{</span> <span class="no">MentionNotificationJob</span><span class="p">.</span><span class="nf">deliver_later</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">DB</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
  <span class="n">author</span><span class="p">.</span><span class="nf">comments_dataset</span><span class="p">.</span><span class="nf">paged_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">comment</span><span class="o">|</span>
    <span class="c1"># The transaction hooks aren't registered, so Ruby can garbage collect</span>
    <span class="c1"># these model instances while the loop is running.</span>
    <span class="n">comment</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="ss">author: </span><span class="n">new_author</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We can also register a transaction hook in a way where it will only keep the
reference to the record id instead of the whole record instance:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MentionNotifications</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">comment_id</span><span class="p">)</span>
    <span class="n">db</span><span class="p">.</span><span class="nf">after_commit</span> <span class="p">{</span> <span class="no">MentionNotificationJob</span><span class="p">.</span><span class="nf">deliver_later</span><span class="p">(</span><span class="n">comment_id</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Comment</span> <span class="o">&lt;</span> <span class="no">Sequel</span><span class="o">::</span><span class="no">Model</span>
  <span class="k">def</span> <span class="nf">after_save</span>
    <span class="no">NotificationMentions</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="transaction-state">Transaction state</h2>

<h3 id="active-record-1">Active Record</h3>

<p>Active Record maintains transaction state on the <a href="https://github.com/rails/rails/blob/f40c17dcfafa57bcbd8fd2ff6745f37334ba78d9/activerecord/lib/active_record/connection_adapters/abstract/transaction.rb">connection
level</a>, but a lot of transaction-related
state is also maintained at the <a href="https://github.com/rails/rails/blob/f40c17dcfafa57bcbd8fd2ff6745f37334ba78d9/activerecord/lib/active_record/transactions.rb">model level</a>.
While the transaction manager is implemented pretty decently, the
<code class="language-plaintext highlighter-rouge">ActiveRecord::Transactions</code> module is incredibly complex, and
<a href="https://github.com/rails/rails/issues/29747">has</a>
<a href="https://github.com/rails/rails/issues/36934">been</a>
<a href="https://github.com/rails/rails/issues/37152">the</a>
<a href="https://github.com/rails/rails/issues/39972">source</a>
<a href="https://github.com/rails/rails/issues/39400">of</a>
<a href="https://github.com/rails/rails/issues/14493">numerous</a>
<a href="https://github.com/rails/rails/issues/36132">issues</a>.</p>

<p>The reason for this complexity is that every new incoming bug has generally
been solved by adding yet another tweak, yet another conditional, yet another
instance variable. And some of these instance variables even leak outside of
the <code class="language-plaintext highlighter-rouge">ActiveRecord::Transactions</code> module, which indicates a leaky abstraction.</p>

<p>Honestly, for me this reached a state where I don’t consider Active Record’s
transaction callbacks to be safe enough for production, and I try to avoid them
whenever possible.</p>

<h3 id="sequel-1">Sequel</h3>

<p>Sequel stores all the transaction state in a single <code class="language-plaintext highlighter-rouge">@transactions</code> instance
variable on the database object. Models don’t have access to the transaction
state, which keeps transactions fully decoupled from models.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">DB</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span> <span class="o">|</span><span class="n">conn</span><span class="o">|</span>
  <span class="no">DB</span><span class="p">.</span><span class="nf">after_commit</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="no">DB</span><span class="p">.</span><span class="nf">transaction</span><span class="p">(</span><span class="ss">savepoint: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">DB</span><span class="p">.</span><span class="nf">instance_variable_get</span><span class="p">(</span><span class="ss">:@transactions</span><span class="p">)[</span><span class="n">conn</span><span class="p">]</span> <span class="c1">#=&gt;</span>
    <span class="c1"># {</span>
    <span class="c1">#   after_commit: [</span>
    <span class="c1">#     &lt;Proc...&gt; # the block we've registered above</span>
    <span class="c1">#   ],</span>
    <span class="c1">#   savepoints: [</span>
    <span class="c1">#     { ... }, # transaction data</span>
    <span class="c1">#     { ... }  # savepoint data</span>
    <span class="c1">#   ]</span>
    <span class="c1"># }</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>If you’re reading <a href="https://github.com/jeremyevans/sequel/blob/1bcb1996fc7be80db8001640aae6fb5a2ca5ff19/lib/sequel/database/transactions.rb">Sequel’s transaction code</a>, you’ll
notice that all of it is contained in a single file and single context
(including transaction hooks). In my experience this made the logic much easier
to grok.</p>

<h2 id="lazy-transactions">Lazy transactions</h2>

<h3 id="active-record-2">Active Record</h3>

<p>In version 6.0, Active Record <a href="https://github.com/rails/rails/commit/0ac81ee6ff3d1625fdbcc40b12c00cbff2208077">introduced</a> a
performance optimization that makes transactions lazy. What this means is that
Active Record will issue BEGIN/COMMIT queries only if there was at least one
query exected inside the transaction block.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
  <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">connection</span><span class="p">.</span><span class="nf">execute</span> <span class="s2">"SELECT 1"</span>
<span class="k">end</span>
<span class="c1"># BEGIN</span>
<span class="c1"># SELECT 1</span>
<span class="c1"># COMMIT</span>

<span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
<span class="k">end</span>
<span class="c1"># (no queries were executed)</span>
</code></pre></div></div>

<p>The main use case behind this addition seems to be saving lots of records whose
attributes didn’t change, where each attempted update would execute empty
BEGIN/COMMIT statements (even though no UPDATE was issued), which didn’t
perform well. A workaround at the time would be to call <code class="language-plaintext highlighter-rouge">record.save if
record.changed?</code> instead.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
<span class="n">article</span><span class="p">.</span><span class="nf">published</span> <span class="c1">#=&gt; true</span>
<span class="n">article</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="ss">published: </span><span class="kp">true</span><span class="p">)</span> <span class="c1"># executed empty BEGIN/COMMIT prior to Active Record 6.0</span>
</code></pre></div></div>

<p>However, as <a href="https://github.com/rails/rails/pull/32647#pullrequestreview-114218234">Sean Griffin had pointed out</a> in the pull
request review, this added significant complexity for very little gain. In
addition to requiring <a href="https://github.com/rails/rails/blob/3803671a816232395f538c61046b00c875c1444b/activerecord/lib/active_record/connection_adapters/abstract/transaction.rb#L219-L221">additional transaction state</a>, each Active Record adapter is now also responsible for <a href="https://github.com/rails/rails/blob/3803671a816232395f538c61046b00c875c1444b/activerecord/lib/active_record/connection_adapters/postgresql_adapter.rb#L689">materializing
transactions when necessary</a>.</p>

<h3 id="sequel-2">Sequel</h3>

<p>In Sequel, opening a transaction will always execute BEGIN/COMMIT statements
(if the transaction commits), regardless of whether any queries were made
inside the block or not.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">DB</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
<span class="k">end</span>
<span class="c1"># BEGIN</span>
<span class="c1"># COMMIT</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Sequel::Model#save</code> behaves differently than <code class="language-plaintext highlighter-rouge">ActiveRecord::Base#save</code>, in
terms that it always executes an UPDATE statement for an existing record
(updating all columns). To update only changed attributes, you would use
<code class="language-plaintext highlighter-rouge">Sequel::Model#save_changes</code>, which doesn’t execute UPDATE if no attributes
have changed. And <code class="language-plaintext highlighter-rouge">Sequel::Model#update</code> calls <code class="language-plaintext highlighter-rouge">#save_changes</code> under the hood:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
<span class="n">article</span><span class="p">.</span><span class="nf">published</span> <span class="c1">#=&gt; true</span>
<span class="n">article</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="ss">published: </span><span class="kp">true</span><span class="p">)</span> <span class="c1"># no queries executed</span>
</code></pre></div></div>

<p>Unlike <code class="language-plaintext highlighter-rouge">ActiveRecord::Base#save</code>, <code class="language-plaintext highlighter-rouge">Sequel::Model#save_changes</code> doesn’t open a
transaction if it won’t execute the UPDATE statement. This seems like a much
more elegant solution to the problem Active Record’s lazy transactions intended
to solve, but with none of the complexity.</p>

<h2 id="final-words">Final words</h2>

<p>I really care that libraries I’m using at work have sufficiently
straightforward internals that I can understand when debugging an issue. When
it comes to database transactions, Active Record’s internal complexity is just
too overwhelming for me (and that’s coming from someone who contributes to open
source on a daily basis).</p>

<p>On the other hand, the Sequel’s transaction implementation was fairly
straightforward to understand, which is all the more impressive considering
that it’s more feature-rich compared to Active Record (see the <a href="http://sequel.jeremyevans.net/rdoc/files/doc/transactions_rdoc.html">docs</a>). And this is not an exception – I regularly see this
pattern whenever I’m reading Sequel’s source code <img class="emoji" title=":wink:" alt=":wink:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png" height="20" width="20"></p>

<p>Hopefully this article will add another point towards Sequel for people
starting new Ruby/Rails projects.</p>


  </div>

  <div class="mt-10 flex">
    
      <a class="w-1/2 -mr-0.5 flex sm:space-x-3 border px-3 py-2 bg-gray-50" href="/rodauth-a-refreshing-authentication-solution-for-ruby/">
        <div class="hidden sm:flex flex-col justify-center">
          <svg class="w-6 h-6 text-gray-300" fill="none" stroke="currentColor" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M15 19l-7-7 7-7"></path>
          </svg>
        </div>
        <div class="flex flex-col space-y-1">
          <span class="uppercase text-xs text-gray-500 font-medium tracking-wider">Previous</span>
          <span class="text-sm sm:text-base font-semibold">Rodauth: A Refreshing Authentication Solution for Ruby</span>
        </div>
      </a>
    
    
      <a class="w-1/2 flex sm:space-x-3 border px-3 py-2 bg-gray-50" href="/inserting-from-datasets-with-sequel/">
        <div class="flex-grow flex flex-col space-y-1">
          <span class="uppercase text-xs text-gray-500 font-medium tracking-wider">Next</span>
          <span class="text-sm sm:text-base font-semibold">Inserting from Datasets with Sequel</span>
        </div>
        <div class="hidden sm:flex flex-col justify-center">
          <svg class="w-6 h-6 text-gray-300" fill="none" stroke="currentColor" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M9 5l7 7-7 7"></path>
          </svg>
        </div>
      </a>
    
  </div>
</article>

<div class="mt-10">
  
  <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'twinblog'; // required: replace example with your forum shortname
    var disqus_identifier = '/the-complexity-of-activerecord-transactions';
    var disqus_url = 'https://janko.io/the-complexity-of-activerecord-transactions/';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



</div>

      </main>
    </div>

    
      <script>
  // Gauges
  var _gauges = _gauges || [];
  (function() {
    var t   = document.createElement('script');
    t.type  = 'text/javascript';
    t.async = true;
    t.id    = 'gauges-tracker';
    t.setAttribute('data-site-id', '51f5bd47f5a1f545ac0000fc');
    t.src = '//secure.gaug.es/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>

    
  </body>
</html>
