<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Http.rb is Great | Janko's Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Http.rb is Great" />
<meta name="author" content="Janko Marohnić" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The Ruby ecosystem has many HTTP clients gems to choose from. Some are built on libcurl (Typhoeus, Curb, Patron), some on Ruby’s Net::HTTP (RestClient, HTTParty, Nestful), some in pure Ruby (HTTPClient, Excon, http.rb), and some are wrappers around existing libraries (Faraday, HTTPI)." />
<meta property="og:description" content="The Ruby ecosystem has many HTTP clients gems to choose from. Some are built on libcurl (Typhoeus, Curb, Patron), some on Ruby’s Net::HTTP (RestClient, HTTParty, Nestful), some in pure Ruby (HTTPClient, Excon, http.rb), and some are wrappers around existing libraries (Faraday, HTTPI)." />
<link rel="canonical" href="https://janko.io/httprb-is-great/" />
<meta property="og:url" content="https://janko.io/httprb-is-great/" />
<meta property="og:site_name" content="Janko’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-02T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Http.rb is Great" />
<meta name="twitter:site" content="@jankomarohnic" />
<meta name="twitter:creator" content="@jankomarohnic" />
<meta property="article:publisher" content="https://www.facebook.com/janko.marohnic/" />
<script type="application/ld+json">
{"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://janko.io/images/logo.png"},"name":"Janko Marohnić"},"headline":"Http.rb is Great","dateModified":"2018-06-02T00:00:00+02:00","datePublished":"2018-06-02T00:00:00+02:00","url":"https://janko.io/httprb-is-great/","author":{"@type":"Person","name":"Janko Marohnić"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://janko.io/httprb-is-great/"},"@type":"BlogPosting","description":"The Ruby ecosystem has many HTTP clients gems to choose from. Some are built on libcurl (Typhoeus, Curb, Patron), some on Ruby’s Net::HTTP (RestClient, HTTParty, Nestful), some in pure Ruby (HTTPClient, Excon, http.rb), and some are wrappers around existing libraries (Faraday, HTTPI).","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link type="application/atom+xml" rel="alternate" href="https://janko.io/feed.xml" title="Janko&apos;s Blog" />
    <link rel="stylesheet" href="/css/bundle.css">
  </head>

  <body class="text-xl text-gray-700">
    <header class="py-3 px-4 flex flex-col space-y-1 bg-gray-100 border-b">
      <div class="flex justify-center">
        <a class="flex items-center space-x-2" href="/">
          <img class="h-8" src="/images/logo.png" alt="logo">
          <span class="text-2xl md:text-3xl font-semibold text-pink-700">Janko's Blog</span>
        </a>
      </div>
      <div class="flex justify-center">
        <span class="text-base md:text-lg text-gray-500">Sharing the wonders of Ruby
      </span>
</div>
    </header>

    <div class="my-6 sm:my-8 mx-4">
      <main class="max-w-screen-sm md:max-w-screen-md mx-auto">
        <article>
  <header class="space-y-4 md:space-y-5">
    <h1 class="lg:-mx-28 text-3xl sm:text-4xl lg:text-5xl text-center font-medium text-gray-900">Http.rb is Great</h1>

    <div class="flex justify-center">
      <div class="flex flex-col items-center sm:flex-row sm:items-baseline space-y-3 sm:space-y-0 sm:space-x-4 text-sm md:text-base">
        <span class="text-gray-500">
          By <a class="underline hover:text-gray-700" href="/about">Janko Marohnić</a> on
          <time datetime="2018-06-02 00:00:00 +0200">
            02 Jun 2018
          </time>
        </span>
        
      </div>
    </div>
  </header>

  <div class="mt-4 sm:mt-6 prose md:prose-xl">
    <p>The Ruby ecosystem has many HTTP clients gems to choose from. Some are built on
<a href="https://curl.haxx.se/libcurl/">libcurl</a> (<a href="https://github.com/typhoeus/typhoeus">Typhoeus</a>, <a href="https://github.com/taf2/curb">Curb</a>, <a href="https://github.com/toland/patron">Patron</a>), some on Ruby’s <a href="https://ruby-doc.org/stdlib-2.5.0/libdoc/net/http/rdoc/Net/HTTP.html">Net::HTTP</a>
(<a href="http://github.com/rest-client/rest-client">RestClient</a>, <a href="https://github.com/jnunemaker/httparty">HTTParty</a>, <a href="https://github.com/maccman/nestful">Nestful</a>), some in pure Ruby (<a href="https://github.com/nahi/httpclient">HTTPClient</a>,
<a href="https://github.com/excon/excon">Excon</a>, <a href="https://github.com/httprb/http">http.rb</a>), and some are wrappers around existing libraries
(<a href="https://github.com/lostisland/faraday">Faraday</a>, <a href="https://github.com/savonrb/httpi">HTTPI</a>).</p>

<div class="media">
  <img alt="Taxonomy of Ruby HTTP client libraries" src="/images/ruby-http-client-taxonomy.png">
</div>

<p>Over the years I’ve had the opportunity to try out most of these libraries, but
ever since I discovered <strong><a href="https://github.com/httprb/http">http.rb</a></strong> a year ago, it’s been my favourite
HTTP client library. So, in this post I would like to talk about the features
that make http.rb stand out for me.</p>

<h2 id="nethttp">Net::HTTP</h2>

<p>Before we start, I would like to say a few words about Net::HTTP. Net::HTTP is
the HTTP client that comes with the Ruby standard library, and it’s used in
many places. People often reach for it when they want something simple, or they
use it indirectly through gems like RestClient and HTTParty.</p>

<p>However, whenever I used Net::HTTP, I always had a bad time. Some of the reasons
were</p>

<ul>
  <li>inconsistent and overly verbose API that’s tough to remember</li>
  <li>poorly designed internals making the code difficult to read</li>
  <li>having to handle low-level system call exceptions</li>
</ul>

<p>To illustrate, in my previous job we used Net::HTTP for notifying webhooks, and
this is the code that we ended up with:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">post_payload</span><span class="p">(</span><span class="n">callback_url</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
  <span class="n">uri</span> <span class="o">=</span> <span class="no">URI</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">callback_url</span><span class="p">)</span>

  <span class="n">options</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">open_timeout: </span><span class="mi">15</span><span class="p">,</span> <span class="ss">read_timeout: </span><span class="mi">30</span> <span class="p">}</span>
  <span class="n">options</span><span class="p">.</span><span class="nf">merge!</span><span class="p">(</span><span class="ss">use_ssl: </span><span class="kp">true</span><span class="p">)</span> <span class="k">if</span> <span class="n">uri</span><span class="p">.</span><span class="nf">scheme</span> <span class="o">==</span> <span class="s2">"https"</span>

  <span class="no">Net</span><span class="o">::</span><span class="no">HTTP</span><span class="p">.</span><span class="nf">start</span><span class="p">(</span><span class="n">uri</span><span class="p">.</span><span class="nf">host</span><span class="p">,</span> <span class="n">uri</span><span class="p">.</span><span class="nf">port</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">http</span><span class="o">|</span>
    <span class="n">post</span> <span class="o">=</span> <span class="no">Net</span><span class="o">::</span><span class="no">HTTP</span><span class="o">::</span><span class="no">Post</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">uri</span><span class="p">.</span><span class="nf">request_uri</span><span class="p">)</span>
    <span class="n">post</span><span class="p">.</span><span class="nf">body</span> <span class="o">=</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    <span class="n">post</span><span class="p">[</span><span class="s2">"Content-Type"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"application/json"</span>

    <span class="n">http</span><span class="p">.</span><span class="nf">request</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">rescue</span> <span class="no">SocketError</span><span class="p">,</span>
       <span class="no">EOFError</span><span class="p">,</span>
       <span class="no">IOError</span><span class="p">,</span>
       <span class="no">SystemCallError</span><span class="p">,</span> <span class="c1"># superclass for all Errno::* exceptions</span>
       <span class="no">Timeout</span><span class="o">::</span><span class="no">Error</span><span class="p">,</span> <span class="c1"># superclass for Net::ReadTimeout and Net::OpenTimeout</span>
       <span class="no">Net</span><span class="o">::</span><span class="no">HTTPBadResponse</span><span class="p">,</span>
       <span class="no">Net</span><span class="o">::</span><span class="no">HTTPHeaderSyntaxError</span><span class="p">,</span>
       <span class="no">Net</span><span class="o">::</span><span class="no">ProtocolError</span><span class="p">,</span>
       <span class="no">OpenSSL</span><span class="o">::</span><span class="no">SSL</span><span class="o">::</span><span class="no">SSLError</span>
  <span class="c1"># handle exception</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The wish to make performing tasks like these easier was probably what motivated
people to build HTTP client gems on top of Net::HTTP (RestClient, HTTParty,
Nestful etc). They wanted to improve the API, but didn’t want to reimplement
the HTTP protocol. However, I found the Net::HTTP codebase to be very
convoluted, and always felt frustrated whenever I needed to read it. So, I
don’t think that building on top of Net::HTTP is a good design decision,
because Net::HTTP is not a clean implementation of the HTTP protocol to begin
with.</p>

<p>When creating http.rb, Tony Arcieri decided to rebuild the HTTP protocol
natively in Ruby (and also created the <a href="https://github.com/socketry/socketry">Socketry</a> gem to make working with
TCP/UDP sockets easier). This allowed http.rb to have a fresh start, without
the Net::HTTP baggage.</p>

<blockquote>
  <p>http.rb was born out of rage from using Net::HTTP</p>

  <p>— Tony Arcieri, creator of http.rb</p>
</blockquote>

<h2 id="refreshing-api">Refreshing API</h2>

<p>One of the important goals of http.rb was to make the API easy to use. Let’s
rewrite the previous Net::HTTP example of POSTing a JSON payload to an URL,
this time using http.rb.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">post_payload</span><span class="p">(</span><span class="n">callback_url</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
  <span class="n">http</span> <span class="o">=</span> <span class="no">HTTP</span><span class="p">.</span><span class="nf">timeout</span><span class="p">(</span><span class="ss">connect: </span><span class="mi">15</span><span class="p">,</span> <span class="ss">read: </span><span class="mi">30</span><span class="p">)</span>
  <span class="n">http</span><span class="p">.</span><span class="nf">post</span><span class="p">(</span><span class="n">callback_url</span><span class="p">,</span> <span class="ss">json: </span><span class="n">payload</span><span class="p">)</span>
<span class="k">rescue</span> <span class="no">HTTP</span><span class="o">::</span><span class="no">Error</span>
  <span class="c1"># handle exception</span>
<span class="k">end</span>
</code></pre></div></div>

<p><em>Much</em> easier! Unlike Net::HTTP, http.rb wraps all low-level exceptions into a
nice exception hierarchy that’s easy to handle:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">HTTP::Error</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">HTTP::ConnectionError</code></li>
      <li><code class="language-plaintext highlighter-rouge">HTTP::RequestError</code></li>
      <li><code class="language-plaintext highlighter-rouge">HTTP::ResponseError</code></li>
      <li><code class="language-plaintext highlighter-rouge">HTTP::TimeoutError</code></li>
      <li><code class="language-plaintext highlighter-rouge">HTTP::HeaderError</code></li>
    </ul>
  </li>
</ul>

<p>Here is a more comprehensive example of interaction with http.rb objects:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">response</span> <span class="o">=</span> <span class="no">HTTP</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"https://example.com"</span><span class="p">)</span>
<span class="n">response</span> <span class="c1"># =&gt; #&lt;HTTP::Response/1.1 200 OK ...&gt;</span>

<span class="n">response</span><span class="p">.</span><span class="nf">status</span>          <span class="c1"># =&gt; #&lt;HTTP::Response::Status 200 OK&gt;</span>
<span class="n">response</span><span class="p">.</span><span class="nf">status</span><span class="p">.</span><span class="nf">code</span>     <span class="c1"># =&gt; 200</span>
<span class="n">response</span><span class="p">.</span><span class="nf">status</span><span class="p">.</span><span class="nf">ok?</span>      <span class="c1"># =&gt; true (200)</span>
<span class="n">response</span><span class="p">.</span><span class="nf">status</span><span class="p">.</span><span class="nf">success?</span> <span class="c1"># =&gt; true (200..299)</span>

<span class="n">response</span><span class="p">.</span><span class="nf">headers</span>         <span class="c1"># =&gt; #&lt;HTTP::Headers {…}&gt;</span>
<span class="n">response</span><span class="p">.</span><span class="nf">headers</span><span class="p">.</span><span class="nf">to_h</span>    <span class="c1"># =&gt; { "Content-Type"=&gt;"text/html", ... }</span>

<span class="n">response</span><span class="p">.</span><span class="nf">body</span>            <span class="c1"># =&gt; #&lt;HTTP::Response::Body&gt;</span>
<span class="n">response</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">to_s</span>       <span class="c1"># =&gt; "&lt;!doctype html&gt;..."</span>
</code></pre></div></div>

<p>Where http.rb really shines is its chainable API for building request options.
You can use it to build an HTTP client with default request options, and then
make subsequent requests with it.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Build an HTTP::Client with default request options</span>
<span class="n">http</span> <span class="o">=</span> <span class="no">HTTP</span>
  <span class="p">.</span><span class="nf">headers</span><span class="p">(</span><span class="s2">"User-Agent"</span> <span class="o">=&gt;</span> <span class="s2">"MyApp/1.0.0"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="ss">:json</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">basic_auth</span><span class="p">(</span><span class="ss">user: </span><span class="s2">"janko"</span><span class="p">,</span> <span class="ss">pass: </span><span class="s2">"secret"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">via</span><span class="p">(</span><span class="s2">"https://proxy.com"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">follow</span><span class="p">(</span><span class="ss">max_hops: </span><span class="mi">2</span><span class="p">)</span>

<span class="n">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"https://blog.com/posts"</span><span class="p">)</span>
<span class="n">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"https://blog/com/posts/1"</span><span class="p">)</span>
<span class="n">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"https://blog/com/posts/1/comments"</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="streaming">Streaming</h2>

<p>One of the features of http.rb that I like very much is the support for
streaming requests and responses. This is really useful when you need to
transfer large amounts of data over-the-wire which you don’t want to load into
memory all at once (think uploading and downloading large files).</p>

<h3 id="uploads">Uploads</h3>

<p>There are two ways you can stream content into the request body with http.rb.
One is providing an <a href="https://ruby-doc.org/core-2.5.1/Enumerable.html">Enumerable</a> object, where you can have <code class="language-plaintext highlighter-rouge">#each</code> lazily
generate chunks of content for the request body. The easiest way is to create
an <a href="https://ruby-doc.org/core-2.5.1/Enumerator.html">Enumerator</a> object.</p>

<p>Another way is providing an <a href="https://ruby-doc.org/core-2.5.1/IO.html">IO</a>-like object that implements <a href="http://ruby-doc.org/core-2.5.0/IO.html#method-i-read"><code class="language-plaintext highlighter-rouge">IO#read</code></a>. In
this case http.rb will read the IO content in small chunks and write them to
the request body. Notice that the object doesn’t have to be an actual <code class="language-plaintext highlighter-rouge">File</code>
instance, which is very convenient in contexts such as <a href="https://github.com/shrinerb/shrine">Shrine</a>, where the
“file” to be uploaded can be a <code class="language-plaintext highlighter-rouge">File</code>, <code class="language-plaintext highlighter-rouge">Tempfile</code>, <code class="language-plaintext highlighter-rouge">StringIO</code>,
<code class="language-plaintext highlighter-rouge">ActionDispatch::Http::UploadedFile</code>, <a href="https://github.com/shrinerb/shrine/tree/c02a005869c536eeb234353f5b1129b9e2559559#uploaded-file"><code class="language-plaintext highlighter-rouge">Shrine::UploadedFile</code></a>,
<a href="https://github.com/janko/down/tree/55c9299c170b828d83487bae7df59cfe935a1e35#streaming"><code class="language-plaintext highlighter-rouge">Down::ChunkedIO</code></a>, or any other object that implements <code class="language-plaintext highlighter-rouge">IO#read</code>.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">HTTP</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="s2">"http://example.com/upload"</span><span class="p">,</span> <span class="ss">body: </span><span class="n">io</span><span class="p">)</span> <span class="c1"># streaming upload</span>
</code></pre></div></div>

<h4 id="multipart-form-data">Multipart Form Data</h4>

<p>Http.rb will stream request bodies in <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST#Example">multipart form data</a> format as well:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">HTTP</span><span class="p">.</span><span class="nf">post</span><span class="p">(</span><span class="s2">"http://example.com/upload"</span><span class="p">,</span> <span class="ss">form: </span><span class="p">{</span> <span class="ss">file: </span><span class="no">HTTP</span><span class="o">::</span><span class="no">FormData</span><span class="o">::</span><span class="no">File</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">io</span><span class="p">)</span> <span class="p">})</span>
</code></pre></div></div>

<p>It uses the <a href="https://github.com/httprb/form_data">http-form_data</a> gem to create a <code class="language-plaintext highlighter-rouge">HTTP::FormData::Multipart</code>
object, which implements <code class="language-plaintext highlighter-rouge">IO#read</code> an generates multipart form data body
on-the-fly, so streaming works on the same principle as above. The
implementation of the streaming functionality in <code class="language-plaintext highlighter-rouge">http-form_data</code> was inspired
by the <a href="https://github.com/nicksieger/multipart-post"><code class="language-plaintext highlighter-rouge">multipart-post</code></a> gem.</p>

<p>Even though the <code class="language-plaintext highlighter-rouge">multipart-post</code> gem exists, and <a href="https://github.com/ruby/ruby/blob/v2_5_1/lib/net/http/generic_request.rb#L210-L285">Net::HTTP itself has
multipart form data functionality</a>,
<a href="https://github.com/rest-client/rest-client/blob/v2.0.2/lib/restclient/payload.rb#L116-L207">RestClient</a> and <a href="https://github.com/jnunemaker/httparty/blob/v0.16.2/lib/httparty/request/body.rb#L5">HTTParty</a> still
decided to implement their own. RestClient writes the multipart form data body
to disk before sending it (Net::HTTP does this as well), while RestClient loads
the whole body into memory. When uploading large files, both of these approaches
require resource planning, so that you don’t risk running out of disk/memory.</p>

<p>The advantage of http.rb’s streaming approach is that resource usage doesn’t
grow with the size of the request body, so it’s suitable for large payloads.
What’s also great is that <code class="language-plaintext highlighter-rouge">http-form_data</code> is a generic gem which can be reused
by any HTTP client library, so the Ruby ecosystem can standardise on this
implementation instead of reinventing the wheel.</p>

<h3 id="downloads">Downloads</h3>

<p>When you make a request with http.rb, the response headers are immediately
retrieved, but not the response body, giving you the chance to stream it if you
want to.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># retrieves the whole response body as a string</span>
<span class="no">HTTP</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"http://example.com/download"</span><span class="p">).</span><span class="nf">to_s</span>

<span class="c1"># streams the response body in chunks</span>
<span class="n">response</span> <span class="o">=</span> <span class="no">HTTP</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"http://example.com/download"</span><span class="p">)</span>
<span class="n">response</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">chunk</span><span class="o">|</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This API allowed me to easily implement <a href="https://github.com/janko/down/tree/v4.5.0#streaming">on-demand downloads</a> for Shrine, which
is useful if you want to determine the MIME type of a remote file, but don’t
want to download the whole file for that (MIME type can typically be determined
from the first few kilobytes of the file).</p>

<p>Net::HTTP also supports streaming the response body, but the API is much more
limiting due to having to wrap the streaming in the <code class="language-plaintext highlighter-rouge">Net::HTTP.start</code> block. I
was eventually able to implement on-demand downloads for Net::HTTP as well, but
I had to <a href="https://twin.github.io/partial-downloads-with-enumerators-and-fibers/">use Fibers</a> to work around this limitation.</p>

<h2 id="persistent-connections">Persistent Connections</h2>

<p>Http.rb supports persistent (keep-alive) connections, which allows you to reuse
the same TCP socket for multiple requests to the same domain. This way you
don’t have to pay the price of establishing a connection for each request, which
can make a significant difference in performance.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">HTTP</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"https://example.com"</span><span class="p">).</span><span class="nf">to_s</span> <span class="c1"># connect + write + read + close</span>
<span class="no">HTTP</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"https://example.com"</span><span class="p">).</span><span class="nf">to_s</span> <span class="c1"># connect + write + read + close</span>
<span class="no">HTTP</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"https://example.com"</span><span class="p">).</span><span class="nf">to_s</span> <span class="c1"># connect + write + read + close</span>
</code></pre></div></div>
<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">HTTP</span><span class="p">.</span><span class="nf">persistent</span><span class="p">(</span><span class="s2">"https://example.com"</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">http</span><span class="o">|</span>
  <span class="n">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"/"</span><span class="p">).</span><span class="nf">to_s</span> <span class="c1"># connect + write + read</span>
  <span class="n">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"/"</span><span class="p">).</span><span class="nf">to_s</span> <span class="c1"># write + read</span>
  <span class="n">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"/"</span><span class="p">).</span><span class="nf">to_s</span> <span class="c1"># write + read</span>
<span class="k">end</span>                  <span class="c1"># close</span>

<span class="c1"># OR</span>

<span class="n">http</span> <span class="o">=</span> <span class="no">HTTP</span><span class="p">.</span><span class="nf">persistent</span><span class="p">(</span><span class="s2">"https://example.com"</span><span class="p">)</span>
<span class="n">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"/"</span><span class="p">).</span><span class="nf">to_s</span> <span class="c1"># connect + write + read</span>
<span class="n">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"/"</span><span class="p">).</span><span class="nf">to_s</span> <span class="c1"># write + read</span>
<span class="n">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"/"</span><span class="p">).</span><span class="nf">to_s</span> <span class="c1"># write + read</span>
<span class="n">http</span><span class="p">.</span><span class="nf">close</span>         <span class="c1"># close</span>
</code></pre></div></div>

<p>On a Heroku dyno, the first example takes about <strong>1.1s</strong>, whereas the example
that uses a persistent connection takes only <strong>0.6s</strong>, which shows that the
performance difference can be significant.</p>

<p>Net::HTTP also supports persistent connections, but requests have to be
performed inside the <code class="language-plaintext highlighter-rouge">Net::HTTP.start</code> block (alternatively you can use
<a href="https://github.com/drbrain/net-http-persistent">net-http-persistent</a>). HTTP client libraries built on top of libcurl
automatically use persistent connections (as that feature is built into
libcurl), so with them you don’t need to think about it.</p>

<h2 id="timeouts">Timeouts</h2>

<p>Like most HTTP client libraries, http.rb allows you to specify connect and read
timeout. Connect timeout limits the time for opening the TCP connection, while
read timeout limits the time of reading a single chunk of the response.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">http</span> <span class="o">=</span> <span class="no">HTTP</span><span class="p">.</span><span class="nf">timeout</span><span class="p">(</span><span class="ss">connect: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">read: </span><span class="mi">1</span><span class="p">)</span>
<span class="n">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"http://example.com"</span><span class="p">)</span> <span class="c1"># raises HTTP::TimeoutError</span>
</code></pre></div></div>

<p>Net::HTTP also has connect and read timeout, but it has a caveat for read
timeout – idempotent requests will be automatically retried on timeout error.
This means that, if you specify read timeout of 4 seconds, a request could
raise a timeout error only after 8 seconds, because it was already retried
once. See <a href="https://engineering.wework.com/ruby-users-be-wary-of-net-http-f284747288b2">this article</a> for more details.</p>

<h3 id="write-timeout">Write timeout</h3>

<p>In addition to connect and read timeout, http.rb also comes with a <strong>write
timeout</strong>. A write timeout limits the time it takes to write a single chunk of
the request. It’s important to have this feature when sending requests with
large bodies, as those require multiple write system calls.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">HTTP</span><span class="p">.</span><span class="nf">timeout</span><span class="p">(</span><span class="ss">connect: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">write: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">read: </span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>There is a <a href="https://bugs.ruby-lang.org/issues/13396">feature request</a> to add write timeout to
Net::HTTP, but as of this writing it hasn’t been implemented yet. I’m not aware
of any HTTP client library that supports write timeouts.</p>

<h3 id="global-timeout">Global timeout</h3>

<p>Requests can be written and responses can be read in multiple write or read
system calls. The default <code class="language-plaintext highlighter-rouge">:read</code> and <code class="language-plaintext highlighter-rouge">:write</code> timeout limits the time <em>for
each operation</em>. This means that if you set <code class="language-plaintext highlighter-rouge">:connect</code>, <code class="language-plaintext highlighter-rouge">:read</code>, and <code class="language-plaintext highlighter-rouge">:write</code>
timeouts to 1 second each, the request could still potentially take longer than
3 seconds if multiple write or read calls are executed.</p>

<p>Http.rb has the ability to specify a <strong>global timeout</strong>, where you can limit
the total amount of time the HTTP request can take. This is again most useful
with large amounts of data, where potentially many write/read system calls will
be executed.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># request can take 2 + 1 + 2 = 5 seconds in total</span>
<span class="no">HTTP</span><span class="p">.</span><span class="nf">timeout</span><span class="p">(</span><span class="ss">:global</span><span class="p">,</span> <span class="ss">connect: </span><span class="mi">2</span><span class="p">,</span> <span class="ss">write: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">read: </span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>It might be tempting to just wrap the whole HTTP call in a <a href="https://ruby-doc.org/stdlib-2.5.1/libdoc/timeout/rdoc/Timeout.html"><code class="language-plaintext highlighter-rouge">Timeout</code></a> block,
but remember, <a href="http://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/">Timeout API is dangerous</a>. Http.rb implements read and write
timeouts natively, it only uses <code class="language-plaintext highlighter-rouge">Timeout</code> for the connect timeout (as doing it
natively is <a href="https://github.com/socketry/socketry/blob/ddc852443c66fc757f20cf0c0aacbaace6873ac4/lib/socketry/tcp/socket.rb#L81-L105">a bit more involved</a>).</p>

<h2 id="compression">Compression</h2>

<p>The HTTP 1.1 protocol supports compressing request and response bodies, which
decreases network resource usage, with the cost of increased CPU usage needed
for (de)compressing. This can improve speed when transferring large amounts of
data, depending on how well the request/response bodies compress.</p>

<p>Http.rb has support for automatically compressing (“deflating”) request bodies:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">HTTP</span><span class="p">.</span><span class="nf">use</span><span class="p">(</span><span class="ss">:auto_deflate</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">post</span><span class="p">(</span><span class="s2">"http://example.com/upload"</span><span class="p">,</span> <span class="ss">body: </span><span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"file.txt"</span><span class="p">))</span> <span class="c1"># compression</span>

<span class="c1"># POST /upload HTTP/1.1</span>
<span class="c1"># Content-Length: 53057934</span>
<span class="c1"># Content-Encoding: gzip  &lt;========</span>
<span class="c1">#</span>
<span class="c1"># [compressed content]</span>
</code></pre></div></div>

<p>and automatically decompressing (“inflating”) response bodies:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">HTTP</span><span class="p">.</span><span class="nf">use</span><span class="p">(</span><span class="ss">:auto_inflate</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"http://example.com/download"</span><span class="p">)</span> <span class="c1"># compression</span>

<span class="c1"># HTTP/1.1 200 OK</span>
<span class="c1"># Content-Length: 53057934</span>
<span class="c1"># Content-Encoding: gzip  &lt;========</span>
<span class="c1">#</span>
<span class="c1"># [compressed content]</span>
</code></pre></div></div>

<p>This works with streaming requests and responses. For regular requests the
total size needs to be calculated first for setting the <code class="language-plaintext highlighter-rouge">Content-Length</code>
request header, so in this case the compressed request body will be written
to disk before it’s sent. But with <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding">chunked requests</a> the request body will be
compressed on-the-fly, as those don’t require the <code class="language-plaintext highlighter-rouge">Content-Length</code> request
header.</p>

<h2 id="memory-usage">Memory Usage</h2>

<p>Ruby processes tend to consume a lot of memory. Ruby developers deal with this
in various ways: tweaking Ruby’s GC settings, killing web workers once they
reach certain memory threshold, running the Ruby processes on jemalloc etc.
However, I think there are still many opportunities for reducing the amount of
objects we allocate in the first place, which is the approach that <a href="https://schneems.com">Richard
Schneeman</a> (<a href="https://github.com/schneems/derailed_benchmarks">derailed_benchmarks</a> &amp; countless PRs), <a href="https://samsaffron.com">Sam Saffron</a>
(<a href="https://github.com/MiniProfiler/rack-mini-profiler">rack-mini-profiler</a>, <a href="https://github.com/samsaffron/memory_profiler">memory_profiler</a>, <a href="https://github.com/SamSaffron/flamegraph">flamegraph</a>, <a href="https://rubybench.org">RubyBench.org</a>), and
Eric Wong (Ruby commits) actively promote.</p>

<p>Eric Wong (Unicorn author and Ruby committer) recently talked about
this in a ruby-talk thread titled “<a href="https://rubytalk.org/t/psa-string-memory-use-reduction-techniques/74477">String memory use reduction techniques</a>”.
There, Eric states that what is often to blame for high memory usage in Ruby
applications are <strong>string objects</strong>. He shows various techniques for limiting
string allocations, as well as deallocating strings that are no longer needed.
After all, the less “garbage” there is, the better the garbage collector will
perform <img class="emoji" title=":wink:" alt=":wink:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png" height="20" width="20"></p>

<p>It so happens that HTTP intractions can allocate a lot of strings, especially
for large request and response bodies. I <a href="https://gist.github.com/janko/238bbcc78b369ce3438365e5507bc671">measured</a> memory
usage of http.rb, Net::HTTP, RestClient, and HTTParty when uploading and
downloading 10 MB of data. Here are the results:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Library</th>
      <th style="text-align: right">Uploading 10MB</th>
      <th style="text-align: right">Downloading 10MB</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">http.rb</td>
      <td style="text-align: right">0.10 MB</td>
      <td style="text-align: right">0.2 MB</td>
    </tr>
    <tr>
      <td style="text-align: left">Net::HTTP</td>
      <td style="text-align: right">0.02 MB</td>
      <td style="text-align: right">12.36 MB</td>
    </tr>
    <tr>
      <td style="text-align: left">RestClient</td>
      <td style="text-align: right">9.03 MB</td>
      <td style="text-align: right">12.57 MB</td>
    </tr>
    <tr>
      <td style="text-align: left">HTTParty</td>
      <td style="text-align: right">40.03 MB</td>
      <td style="text-align: right">12.59 MB</td>
    </tr>
  </tbody>
</table>

<p>In the uploading benchmark, we can see that http.rb and Net::HTTP memory usage
is low, RestClient allocates 1x the request body size, and HTTParty allocates
4x the request body size. The http.rb memory usage is slightly higher, but it
appears to be constant regardless of the request body size. Note that with
uploads over SSL the memory usage will be much higher for each library, because
Ruby’s <code class="language-plaintext highlighter-rouge">OpenSSL::SSL::SSLSocket</code> is currently very memory-inefficient (but
there is a <a href="https://bugs.ruby-lang.org/issues/14426">patch</a> waiting to be merged).</p>

<p>In the downloading benchmark, http.rb has very low memory usage which stays the
same regardless of the response body size, while the other libraries allocate
approximately 1x the response body size (due to Net::HTTP). Note that this
will be fixed in Ruby 2.6.0 due to Eric Wong’s recent <a href="https://bugs.ruby-lang.org/issues/14326">patch</a>, after which memory consumption drops to the same levels as
http.rb.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I found http.rb to be a very impressive HTTP client library. It has a very nice
easy-to-use API, good exception hierarchy, full streaming support, persistent
connections, advanced timeout options, HTTP compression support and more.</p>

<p>I believe that one of the main things that helped it shape up is implementing
the HTTP protocol natively instead of relying on Net::HTTP. This also spawned
some reusable libraries – <a href="https://github.com/socketry/socketry">Socketry</a>, <a href="https://github.com/httprb/form_data">http-form_data</a>, and <a href="https://github.com/httprb/content_type.rb">content-type</a> –
which is always sound sign of good design in my book.</p>

<p>Since I maintain libraries for handling file uploads and downloads (<a href="https://github.com/shrinerb/shrine">Shrine</a>,
<a href="https://github.com/janko/down">Down</a>, <a href="https://github.com/janko/tus-ruby-server">tus-ruby-server</a>), it’s important to me to have an HTTP client library
that I can recommend. The streaming upload/download support and very low memory
usage makes http.rb a great choice, especially when dealing with large files.</p>

<p>I encourage you to try http.rb on your next project!</p>


  </div>
</article>

<div class="mt-8 md:mt-10">
  
  <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'twinblog'; // required: replace example with your forum shortname
    var disqus_identifier = '/httprb-is-great';
    var disqus_url = 'https://janko.io/httprb-is-great/';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



</div>

      </main>
    </div>

    
      <script>
  // Gauges
  var _gauges = _gauges || [];
  (function() {
    var t   = document.createElement('script');
    t.type  = 'text/javascript';
    t.async = true;
    t.id    = 'gauges-tracker';
    t.setAttribute('data-site-id', '51f5bd47f5a1f545ac0000fc');
    t.src = '//secure.gaug.es/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>

    
  </body>
</html>
