<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Introducing Shrine – A file upload toolkit | Janko's Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Introducing Shrine – A file upload toolkit" />
<meta name="author" content="Janko Marohnić" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I’m really excited about this. I’ve just released Shrine, a new solution for handling file uploads in Ruby applications. It was heavily inspired by Refile, most notably its idea of backends. However, unlike Refile, it is designed primarily for upfront processing (as opposed to on-the-fly). It’s also inspired by CarrierWave’s idea of uploaders." />
<meta property="og:description" content="I’m really excited about this. I’ve just released Shrine, a new solution for handling file uploads in Ruby applications. It was heavily inspired by Refile, most notably its idea of backends. However, unlike Refile, it is designed primarily for upfront processing (as opposed to on-the-fly). It’s also inspired by CarrierWave’s idea of uploaders." />
<link rel="canonical" href="https://janko.io/introducing-shrine/" />
<meta property="og:url" content="https://janko.io/introducing-shrine/" />
<meta property="og:site_name" content="Janko’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-10-04T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Introducing Shrine – A file upload toolkit" />
<meta name="twitter:site" content="@jankomarohnic" />
<meta name="twitter:creator" content="@jankomarohnic" />
<meta property="article:publisher" content="https://www.facebook.com/janko.marohnic/" />
<script type="application/ld+json">
{"dateModified":"2015-10-04T00:00:00+02:00","datePublished":"2015-10-04T00:00:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://janko.io/introducing-shrine/"},"url":"https://janko.io/introducing-shrine/","author":{"@type":"Person","name":"Janko Marohnić"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://janko.io/images/logo.png"},"name":"Janko Marohnić"},"@type":"BlogPosting","description":"I’m really excited about this. I’ve just released Shrine, a new solution for handling file uploads in Ruby applications. It was heavily inspired by Refile, most notably its idea of backends. However, unlike Refile, it is designed primarily for upfront processing (as opposed to on-the-fly). It’s also inspired by CarrierWave’s idea of uploaders.","headline":"Introducing Shrine – A file upload toolkit","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link type="application/atom+xml" rel="alternate" href="https://janko.io/feed.xml" title="Janko&apos;s Blog" />
    <link rel="stylesheet" href="/css/bundle.css">
  </head>

  <body class="text-xl text-gray-700">
    <header class="py-3 px-4 flex flex-col space-y-1 bg-gray-100 border-b">
      <div class="flex justify-center">
        <a class="flex items-center space-x-2" href="/">
          <img class="h-8" src="/images/logo.png" alt="logo" />
          <span class="text-2xl md:text-3xl font-semibold text-pink-700">Janko's Blog</span>
        </a>
      </div>
      <div class="flex justify-center">
        <span class="text-base md:text-lg text-gray-500">Sharing the wonders of Ruby</p>
      </div>
    </header>

    <div class="my-6 sm:my-8 mx-4">
      <main class="max-w-screen-sm md:max-w-screen-md mx-auto">
        <article>
  <header class="space-y-4 md:space-y-5">
    <h1 class="lg:-mx-28 text-3xl sm:text-4xl lg:text-5xl text-center font-medium text-gray-900">Introducing Shrine – A file upload toolkit</h1>

    <div class="flex justify-center">
      <div class="flex flex-col items-center sm:flex-row sm:items-baseline space-y-3 sm:space-y-0 sm:space-x-4 text-sm md:text-base">
        <span class="text-gray-500">
          By <a class="underline hover:text-gray-700" href="/about">Janko Marohnić</a> on
          <time datetime="2015-10-04 00:00:00 +0200">
            04 Oct 2015
          </time>
        </span>
        
          
<a class="my-1 rounded-full px-3 bg-red-light text-red-dark font-semibold py-0.5" href="/shrine">shrine</a>


        
      </div>
    </div>
  </header>

  <div class="mt-4 sm:mt-6 prose md:prose-xl">
    <p>I’m really excited about this. I’ve just released <a href="https://github.com/shrinerb/shrine">Shrine</a>, a new solution for
handling file uploads in Ruby applications. It was heavily inspired by Refile,
most notably its idea of backends. However, unlike Refile, it is designed
primarily for upfront processing (as opposed to on-the-fly). It’s also inspired
by CarrierWave’s idea of uploaders.</p>

<h2 id="flexibility">Flexibility</h2>

<p>Shrine implements a <a href="http://twin.github.io/the-plugin-system-of-sequel-and-roda/">plugin system</a> analogous to <a href="https://github.com/jeremyevans/roda">Roda</a>’s and <a href="https://github.com/jeremyevans/sequel">Sequel</a>’s. It
has a small core which provides only the essential functionality, while other
features come as plugins which can be loaded when needed. Shrine ships with
<a href="http://shrinerb.com#plugins">over 25 plugins</a>, which together provide a great arsenal of features.</p>

<p>This design makes Shrine extremely versatile. File uploads are very delicate,
and need to be handled differently depending on what types of files are being
uploaded, whether there is processing or not, what storage is used etc.
Instead of having an opinion on how you want to do your upload, Shrine allows
you to build an uploading flow that suits your needs.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Shrine</span><span class="p">.</span><span class="nf">plugin</span> <span class="ss">:sequel</span>
<span class="no">Shrine</span><span class="p">.</span><span class="nf">plugin</span> <span class="ss">:pretty_location</span>
<span class="no">Shrine</span><span class="p">.</span><span class="nf">plugin</span> <span class="ss">:logging</span><span class="p">,</span> <span class="ss">format: :json</span>
</code></pre></div></div>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ImageUploader</span> <span class="o">&lt;</span> <span class="no">Shrine</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">Sequel</span><span class="o">::</span><span class="no">Model</span>
  <span class="kp">include</span> <span class="no">ImageUploader</span><span class="o">::</span><span class="no">Attachment</span><span class="p">(</span><span class="ss">:avatar</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">avatar: </span><span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"path/to/avatar.jpg"</span><span class="p">))</span>
<span class="n">user</span><span class="p">.</span><span class="nf">avatar</span><span class="p">.</span><span class="nf">id</span> <span class="c1"># "user/532/avatar/f753g598sm3l2.jpg"</span>
</code></pre></div></div>

<h2 id="simplicity">Simplicity</h2>

<p>Where CarrierWave and other file upload libraries favor complex class-level
DSLs, Shrine favours simple instance-level interface. Here’s an example on how
file processing is done in Shrine:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Gemfile</span>
<span class="n">gem</span> <span class="s2">"image_processing"</span><span class="p">,</span> <span class="s2">"~&gt; 1.2"</span>
</code></pre></div></div>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"image_processing/mini_magick"</span>

<span class="k">class</span> <span class="nc">ImageUploader</span> <span class="o">&lt;</span> <span class="no">Shrine</span>
  <span class="n">plugin</span> <span class="ss">:processing</span>
  <span class="n">plugin</span> <span class="ss">:versions</span>

  <span class="n">process</span><span class="p">(</span><span class="ss">:store</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">io</span><span class="p">,</span> <span class="n">context</span><span class="o">|</span>
    <span class="k">next</span> <span class="k">if</span> <span class="n">context</span><span class="p">[</span><span class="ss">:record</span><span class="p">].</span><span class="nf">guest?</span> <span class="c1"># we have access to the record</span>

    <span class="n">versions</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">original: </span><span class="n">io</span> <span class="p">}</span>

    <span class="n">io</span><span class="p">.</span><span class="nf">download</span> <span class="k">do</span> <span class="o">|</span><span class="n">original</span><span class="o">|</span>
      <span class="n">processor</span> <span class="o">=</span> <span class="no">ImageProcessing</span><span class="o">::</span><span class="no">MiniMagick</span><span class="p">.</span><span class="nf">source</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>

      <span class="n">versions</span><span class="p">[</span><span class="ss">:large</span><span class="p">]</span>  <span class="o">=</span> <span class="n">processor</span><span class="p">.</span><span class="nf">resize_to_limit!</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">800</span><span class="p">)</span>
      <span class="n">versions</span><span class="p">[</span><span class="ss">:medium</span><span class="p">]</span> <span class="o">=</span> <span class="n">processor</span><span class="p">.</span><span class="nf">resize_to_limit!</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
      <span class="n">versions</span><span class="p">[</span><span class="ss">:small</span><span class="p">]</span>  <span class="o">=</span> <span class="n">processor</span><span class="p">.</span><span class="nf">resize_to_limit!</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">versions</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This method gets called whenever a file is uploaded, so you can just use regular
Ruby to specify exactly how and when processing is done. You can also choose
to do some processing on caching as well.</p>

<p>Validations are done in a similar fashion:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ImageUploader</span> <span class="o">&lt;</span> <span class="no">Shrine</span>
  <span class="n">plugin</span> <span class="ss">:validation_helpers</span>

  <span class="no">Attacher</span><span class="p">.</span><span class="nf">validate</span> <span class="k">do</span>
    <span class="c1"># Evaluated inside an instance of Shrine::Attacher.</span>
    <span class="k">unless</span> <span class="n">record</span><span class="p">.</span><span class="nf">admin?</span>
      <span class="n">validate_max_size</span> <span class="mi">2</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span> <span class="ss">message: </span><span class="s2">"is too large (max is 2 MB)"</span>
      <span class="n">validate_mime_type_inclusion</span> <span class="p">[</span><span class="s2">"image/jpg"</span><span class="p">,</span> <span class="s2">"image/png"</span><span class="p">,</span> <span class="s2">"image/gif"</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Another difference from other gems is number of obligatory dependencies.  While
CarrierWave, Refile and Paperlip have 9-12 depedencies in total, Shrine by
default has only 2 – one for downloading files, one for generating a value for
the <code class="language-plaintext highlighter-rouge">Content-Disposition</code> header.</p>

<h2 id="performance">Performance</h2>

<p>Shrine cares a lot about performance. For example, it allows you to minimize
file copying by moving files instead, which is useful when dealing with larger
files, and also means that no temporary files will be left behind.</p>

<p>Shrine also comes with a <code class="language-plaintext highlighter-rouge">parallelize</code> plugin, which uploads and deletes files
in parallel. This is used when you have multiple versions of your files.</p>

<h3 id="background-jobs">Background jobs</h3>

<p>Now we come to a major difference between Shrine and other uploading gems.
Other gems aren’t designed to support backgrounding, and although external gems
exist that add this functionality (e.g. <a href="https://github.com/lardawge/carrierwave_backgrounder">carrierwave_backgrounder</a>), they
require complex setup and in my experience have been very unstable (e.g.
carrierwave_backgrounder breaks removing attachments).</p>

<p>Shrine, on the other hand, embraces that putting phases of file upload into
background jobs is essential for good user experience and scaling, and is
designed from the very beginning with this in mind. It comes with a
<code class="language-plaintext highlighter-rouge">backgrounding</code> plugin, which allows you to put processing, storing and
deleting into a background job:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Shrine</span><span class="p">.</span><span class="nf">plugin</span> <span class="ss">:backgrounding</span>
<span class="no">Shrine</span><span class="o">::</span><span class="no">Attacher</span><span class="p">.</span><span class="nf">promote</span> <span class="p">{</span> <span class="o">|</span><span class="n">data</span><span class="o">|</span> <span class="no">UploadJob</span><span class="p">.</span><span class="nf">perform_async</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">}</span>
<span class="no">Shrine</span><span class="o">::</span><span class="no">Attacher</span><span class="p">.</span><span class="nf">delete</span> <span class="p">{</span> <span class="o">|</span><span class="n">data</span><span class="o">|</span> <span class="no">DeleteJob</span><span class="p">.</span><span class="nf">perform_async</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UploadJob</span>
  <span class="kp">include</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Worker</span>
  <span class="k">def</span> <span class="nf">perform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="no">Shrine</span><span class="o">::</span><span class="no">Attacher</span><span class="p">.</span><span class="nf">promote</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DeleteJob</span>
  <span class="kp">include</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Worker</span>
  <span class="k">def</span> <span class="nf">perform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="no">Shrine</span><span class="o">::</span><span class="no">Attacher</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Notice that, unlike gems like carrierwave_backgrounder, you are required to
write your own job classes, but as you can see, Shrine makes the implementation
very simple. In this example I used Sidekiq, but obviously you can just as well
use any other backgrounding library.</p>

<p>The end user experience was the main guidance in Shrine’s design. Before the
file is moved to store, the record is first saved with the cached version of
the file. This means that, while the file is being processed and stored in the
background, the end user will immediately see the image they uploaded, because
the URL will point to the cached version. So from the user’s perspective, at
this moment the file upload is finished!</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span><span class="p">.</span><span class="nf">avatar</span><span class="p">.</span><span class="nf">url</span> <span class="c1">#=&gt; "/uploads/dso3432kdw032.jpg"</span>
<span class="c1"># ... Background job is done storing ...</span>
<span class="n">user</span><span class="p">.</span><span class="nf">avatar</span><span class="p">.</span><span class="nf">url</span> <span class="c1">#=&gt; "https://s3-sa-east-1.amazonaws.com/my-bucket/0943sf8gfk13.jpg"</span>
</code></pre></div></div>

<p>When the background job finishes, the record will be updated with the stored
version, but the user won’t notice that the URL has changed, because they
will still see the same image. And this is the goal, to make the end user
completely unaware of the internal complexity.</p>

<h3 id="direct-uploads">Direct uploads</h3>

<p>Like Refile, Shrine also supports direct uploads. This means you can cache
files using AJAX, before the form is submitted. This generally provides the best
user experience, because the UI isn’t blocked, and the user knows how much
they have to wait (assuming you give them a progress bar). The endpoint for
direct uploads is provided by the <code class="language-plaintext highlighter-rouge">direct_upload</code> plugin.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ImageUploader</span> <span class="o">&lt;</span> <span class="no">Shrine</span>
  <span class="n">plugin</span> <span class="ss">:direct_upload</span>
<span class="k">end</span>
</code></pre></div></div>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">draw</span> <span class="k">do</span>
  <span class="c1"># adds `POST /attachments/images/:storage/:name`</span>
  <span class="n">mount</span> <span class="no">ImageUploader</span><span class="p">.</span><span class="nf">direct_endpoint</span> <span class="o">=&gt;</span> <span class="s2">"/attachments/images"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Unlike Refile, Shrine doesn’t ship with complete JavaScript which makes this
just work, instead it expects you to use an existing JavaScript library for
file uploads (<a href="https://github.com/blueimp/jQuery-File-Upload">jQuery-File-Upload</a> is really good). This plugin also provides a
presign route which you can use for implementing direct S3 uploads. I created
an <a href="https://github.com/shrinerb/shrine-example">example app</a> to demonstrate how easy it is to implement multiple uploads
directly to S3.</p>

<h2 id="safety">Safety</h2>

<p>File uploads can bring many security vulnerabilities, and Shrine tries to be as
secure as possible.</p>

<p>For example, for extracting image dimensions it uses the <a href="https://github.com/sdsykes/fastimage">fastimage</a> gem, which
has built-in protection against <a href="https://www.bamsoftware.com/hacks/deflate.html">image bombs</a>. Shrine also ships with the
<code class="language-plaintext highlighter-rouge">determine_mime_type</code> plugin which enables you to extract the actual MIME type
of a file (by default it uses the UNIX <a href="http://linux.die.net/man/1/file">file</a> utility).</p>

<p>Shrine normally does processing before storing, which happens after validation
(I say “normally” because you can also choose to process on caching, depending
on your situation). I mention this because CarrierWave does processing <em>before</em>
validation, which is a huge security flaw since it allows attackers to easily
DoS your application by uploading large images (<a href="https://github.com/carrierwaveuploader/carrierwave/issues/1320">#1320</a>).</p>

<p>Shrine also implements <code class="language-plaintext highlighter-rouge">backgrounding</code> in a very safe way. For example, it
could potentially happen that the user changes the attachment before the
background job is finished processing and storing. In this situation a naive
implementation would replace a new file with an old stored one, but Shrine,
once it’s done with processing and storing, checks if the attachment has
changed, and if it did it doesn’t do the replacement.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Shrine ships with <a href="http://shrinerb.com#plugins">a lot of other plugins</a> that I haven’t managed to cover here,
but I encourage you to check them out. I spent a lot of time studying other
solutions and their open issues, and hopefully I succeeded in making Shrine the
next level of file uploads.</p>


  </div>
</article>

<div class="mt-8 md:mt-10">
  
  <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'twinblog'; // required: replace example with your forum shortname
    var disqus_identifier = '/introducing-shrine';
    var disqus_url = 'https://janko.io/introducing-shrine/';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



</div>

      </main>
    </div>

    
      <script>
  // Gauges
  var _gauges = _gauges || [];
  (function() {
    var t   = document.createElement('script');
    t.type  = 'text/javascript';
    t.async = true;
    t.id    = 'gauges-tracker';
    t.setAttribute('data-site-id', '51f5bd47f5a1f545ac0000fc');
    t.src = '//secure.gaug.es/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>

    
  </body>
</html>
