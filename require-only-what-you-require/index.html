<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Require only what you require | Janko's Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Require only what you require" />
<meta name="author" content="Janko Marohnić" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Writing code which reveals intention is one of the most important things to me. Some time ago, I read “5 Reasons to Avoid Bundler.require” by Myron Marston, which talks about how Rails requires all of your gems at startup and some of the downsides of that approach. After reading it, I started noticing how many gems, when they need to require their parts, use a similar approach as Rails by just requiring everything in one place." />
<meta property="og:description" content="Writing code which reveals intention is one of the most important things to me. Some time ago, I read “5 Reasons to Avoid Bundler.require” by Myron Marston, which talks about how Rails requires all of your gems at startup and some of the downsides of that approach. After reading it, I started noticing how many gems, when they need to require their parts, use a similar approach as Rails by just requiring everything in one place." />
<link rel="canonical" href="https://janko.io/require-only-what-you-require/" />
<meta property="og:url" content="https://janko.io/require-only-what-you-require/" />
<meta property="og:site_name" content="Janko’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-01-31T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Require only what you require" />
<meta name="twitter:site" content="@jankomarohnic" />
<meta name="twitter:creator" content="@jankomarohnic" />
<meta property="article:publisher" content="https://www.facebook.com/janko.marohnic/" />
<script type="application/ld+json">
{"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://janko.io/images/logo.png"},"name":"Janko Marohnić"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://janko.io/require-only-what-you-require/"},"author":{"@type":"Person","name":"Janko Marohnić"},"headline":"Require only what you require","dateModified":"2015-01-31T00:00:00+01:00","description":"Writing code which reveals intention is one of the most important things to me. Some time ago, I read “5 Reasons to Avoid Bundler.require” by Myron Marston, which talks about how Rails requires all of your gems at startup and some of the downsides of that approach. After reading it, I started noticing how many gems, when they need to require their parts, use a similar approach as Rails by just requiring everything in one place.","datePublished":"2015-01-31T00:00:00+01:00","url":"https://janko.io/require-only-what-you-require/","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link type="application/atom+xml" rel="alternate" href="https://janko.io/feed.xml" title="Janko's Blog" />
    <link rel="stylesheet" href="/css/bundle.css">
  </head>

  <body class="text-xl text-gray-700">
    <header class="py-3 px-4 flex flex-col space-y-1 bg-gray-100 border-b">
      <div class="flex justify-center">
        <a class="flex items-center space-x-2" href="/">
          <img class="h-8" src="/images/logo.png" alt="logo">
          <span class="text-2xl md:text-3xl font-semibold text-pink-700">Janko's Blog</span>
        </a>
      </div>
      <div class="flex justify-center">
        <span class="text-base md:text-lg text-gray-500">Sharing the wonders of Ruby
      </span>
</div>
    </header>

    <div class="my-6 sm:my-8 mx-3">
      <main class="max-w-screen-sm md:max-w-screen-md mx-auto">
        <article>
  <header class="space-y-4 md:space-y-5">
    <h1 class="lg:-mx-28 text-3xl sm:text-4xl lg:text-5xl text-center font-medium text-gray-900">Require only what you require</h1>

    <div class="flex justify-center">
      <div class="flex flex-col items-center sm:flex-row sm:items-baseline space-y-3 sm:space-y-0 sm:space-x-4 text-sm md:text-base">
        <span class="text-gray-500">
          By <a class="underline hover:text-gray-700" href="/about">Janko Marohnić</a> on
          <time datetime="2015-01-31 00:00:00 +0100">
            31 Jan 2015
          </time>
        </span>
        
      </div>
    </div>
  </header>

  <div class="mt-4 sm:mt-6 prose md:prose-xl">
    <p>Writing code which reveals intention is one of the most important things to me. Some time ago, I read “<a href="http://myronmars.to/n/dev-blog/2012/12/5-reasons-to-avoid-bundler-require">5 Reasons to Avoid Bundler.require</a>” by Myron Marston, which talks about how Rails requires all of your gems at startup and some of the downsides of that approach. After reading it, I started noticing how many gems, when they need to require their parts, use a similar approach as Rails by just requiring everything in one place.</p>

<p>To illustrate, we’ll take a look at a library we’re all using – Rake.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/rake.rb</span>

<span class="nb">require</span> <span class="s1">'rbconfig'</span>
<span class="nb">require</span> <span class="s1">'fileutils'</span>
<span class="nb">require</span> <span class="s1">'singleton'</span>
<span class="nb">require</span> <span class="s1">'monitor'</span>
<span class="nb">require</span> <span class="s1">'optparse'</span>
<span class="nb">require</span> <span class="s1">'ostruct'</span>

<span class="nb">require</span> <span class="s1">'rake/ext/module'</span>
<span class="nb">require</span> <span class="s1">'rake/ext/string'</span>
<span class="nb">require</span> <span class="s1">'rake/ext/time'</span>

<span class="nb">require</span> <span class="s1">'rake/win32'</span>

<span class="nb">require</span> <span class="s1">'rake/linked_list'</span>
<span class="nb">require</span> <span class="s1">'rake/cpu_counter'</span>
<span class="nb">require</span> <span class="s1">'rake/scope'</span>
<span class="nb">require</span> <span class="s1">'rake/task_argument_error'</span>
<span class="nb">require</span> <span class="s1">'rake/rule_recursion_overflow_error'</span>
<span class="nb">require</span> <span class="s1">'rake/rake_module'</span>
<span class="nb">require</span> <span class="s1">'rake/trace_output'</span>
<span class="nb">require</span> <span class="s1">'rake/pseudo_status'</span>
<span class="nb">require</span> <span class="s1">'rake/task_arguments'</span>
<span class="nb">require</span> <span class="s1">'rake/invocation_chain'</span>
<span class="nb">require</span> <span class="s1">'rake/task'</span>
<span class="nb">require</span> <span class="s1">'rake/file_task'</span>
<span class="nb">require</span> <span class="s1">'rake/file_creation_task'</span>
<span class="nb">require</span> <span class="s1">'rake/multi_task'</span>
<span class="nb">require</span> <span class="s1">'rake/dsl_definition'</span>
<span class="nb">require</span> <span class="s1">'rake/file_utils_ext'</span>
<span class="nb">require</span> <span class="s1">'rake/file_list'</span>
<span class="nb">require</span> <span class="s1">'rake/default_loader'</span>
<span class="nb">require</span> <span class="s1">'rake/early_time'</span>
<span class="nb">require</span> <span class="s1">'rake/late_time'</span>
<span class="nb">require</span> <span class="s1">'rake/name_space'</span>
<span class="nb">require</span> <span class="s1">'rake/task_manager'</span>
<span class="nb">require</span> <span class="s1">'rake/application'</span>
<span class="nb">require</span> <span class="s1">'rake/backtrace'</span>
</code></pre></div></div>

<p>What is wrong with this approach?</p>

<h2 id="1-it-doesnt-reveal-intention">1. It doesn’t reveal intention</h2>

<p>Why is <code class="language-plaintext highlighter-rouge">optparse</code> being required here? It isn’t some wide-purpose gem which many files will likely use. It’s actually quite the opposite; <code class="language-plaintext highlighter-rouge">optparse</code> is used for parsing options from the command-line, which will be done once and only once in the code. If we look at <a href="https://github.com/ruby/rake/blob/8cc7349ffbdf97345e5da15e1a05058c6dbcefec/bin/rake">bin/rake</a>, it calls <code class="language-plaintext highlighter-rouge">Rake.applicaton.run</code>, and by grepping we find out that <a href="https://github.com/ruby/rake/blob/8cc7349ffbdf97345e5da15e1a05058c6dbcefec/lib/rake/application.rb">rake/application.rb</a> is the only file which uses <code class="language-plaintext highlighter-rouge">optparse</code>.</p>

<p>If each file requires only what it needs, then we have a nice overview of each file’s dependencies. Now, it can happen that multiple files require the same library. And that’s perfectly ok. Ruby will require each library only once, so the other <code class="language-plaintext highlighter-rouge">require</code>s just won’t do anything. No memory worries <img class="emoji" title=":wink:" alt=":wink:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png" height="20" width="20"></p>

<h2 id="2-it-hides-the-important-parts-of-the-library">2. It hides the important parts of the library</h2>

<p>When we look at this file, it is difficult to tell which are the main components Rake is made of. I don’t think that “linked_list”, “cpu_error” or “rule_recursion_overflow_error” is something I should immediately know about when reading Rake.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'rake/linked_list'</span>  <span class="c1"># &lt;-------------------</span>
<span class="nb">require</span> <span class="s1">'rake/cpu_counter'</span>  <span class="c1"># &lt;-------------------</span>
<span class="nb">require</span> <span class="s1">'rake/scope'</span>
<span class="nb">require</span> <span class="s1">'rake/task_argument_error'</span>
<span class="nb">require</span> <span class="s1">'rake/rule_recursion_overflow_error'</span> <span class="c1"># &lt;--</span>
<span class="nb">require</span> <span class="s1">'rake/rake_module'</span>
<span class="nb">require</span> <span class="s1">'rake/trace_output'</span>  <span class="c1"># &lt;------------------</span>
<span class="nb">require</span> <span class="s1">'rake/pseudo_status'</span>  <span class="c1"># &lt;-----------------</span>
<span class="nb">require</span> <span class="s1">'rake/task_arguments'</span>
<span class="nb">require</span> <span class="s1">'rake/invocation_chain'</span>
<span class="nb">require</span> <span class="s1">'rake/task'</span>
<span class="nb">require</span> <span class="s1">'rake/file_task'</span>
<span class="nb">require</span> <span class="s1">'rake/file_creation_task'</span>
<span class="nb">require</span> <span class="s1">'rake/multi_task'</span>
<span class="nb">require</span> <span class="s1">'rake/dsl_definition'</span>
<span class="nb">require</span> <span class="s1">'rake/file_utils_ext'</span> <span class="c1"># &lt;-----------------</span>
<span class="nb">require</span> <span class="s1">'rake/file_list'</span>
<span class="nb">require</span> <span class="s1">'rake/default_loader'</span>
<span class="nb">require</span> <span class="s1">'rake/early_time'</span> <span class="c1"># &lt;---------------------</span>
<span class="nb">require</span> <span class="s1">'rake/late_time'</span>  <span class="c1"># &lt;---------------------</span>
<span class="nb">require</span> <span class="s1">'rake/name_space'</span>
<span class="nb">require</span> <span class="s1">'rake/task_manager'</span>
<span class="nb">require</span> <span class="s1">'rake/application'</span>
<span class="nb">require</span> <span class="s1">'rake/backtrace'</span>
</code></pre></div></div>

<p>Requiring everything at the top level also encourages a flat structure of the gem. The main file is suddenly responsible for everything, instead letting its main parts require what they need. Then it’s easier to realize which classes belong in which namespaces (directories), and structure becomes more clear.</p>

<h2 id="3-it-hides-dependencies-of-individual-classes">3. It hides dependencies of individual classes</h2>

<p>If files don’t require their own dependencies, it’s more difficult to get a design feedback. If each file would require its own dependencies, we could identify which classes have potentially high coupling by looking at the number of their dependencies.</p>

<p>Furthermore, if each class has its dependencies listed on the top of the file, it’s easier to understand its code. For example, in the implementation of that class I see a call to <code class="language-plaintext highlighter-rouge">#shellescape</code>, without context I wouldn’t know which library it could belong to. However, if I see <code class="language-plaintext highlighter-rouge">require "shellwords"</code> at the top of the file, I would most likely try looking in there, where I would find the wanted method.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"shellwords"</span>

<span class="c1"># ...</span>
<span class="n">command</span> <span class="o">=</span> <span class="s2">"ls </span><span class="si">#{</span><span class="no">File</span><span class="p">.</span><span class="nf">expand_path</span><span class="p">(</span><span class="n">__dir__</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
<span class="n">command</span><span class="p">.</span><span class="nf">shellescape</span>
<span class="c1"># ...</span>
</code></pre></div></div>

<h2 id="4-code-is-still-loaded-after-it-is-no-longer-used">4. Code is still loaded after it is no longer used</h2>

<p>Why are <code class="language-plaintext highlighter-rouge">ostruct</code>, <code class="language-plaintext highlighter-rouge">monitor</code> and <code class="language-plaintext highlighter-rouge">singleton</code> being required here as well? These are all implementation details of Rake’s internal classes. Now, if these internal classes by any chance get refactored, and stop needing one of these dependencies, who will remember to remove these <code class="language-plaintext highlighter-rouge">require</code> statements? Any code that gets loaded when it isn’t used is harmful, because it adds to the load time of the gem (and memory).</p>

<p>There are some cases where something is being used in almost every file, and remembering to require it in every file would be tedious, in which case it makes perfect sense to require it in the top level. But seriously, how often do you use <code class="language-plaintext highlighter-rouge">singleton</code>?</p>

<h2 id="solution">Solution</h2>

<p>What if instead lib/rake.rb looked like this?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/rake.rb (improved)</span>

<span class="nb">require</span> <span class="s2">"rake/application"</span>
<span class="nb">require</span> <span class="s2">"rake/task"</span>
<span class="nb">require</span> <span class="s2">"rake/win32"</span>

<span class="k">module</span> <span class="nn">Rake</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">application</span>
      <span class="vi">@application</span> <span class="o">||=</span> <span class="no">Rake</span><span class="o">::</span><span class="no">Application</span><span class="p">.</span><span class="nf">new</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">application</span><span class="o">=</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
      <span class="vi">@application</span> <span class="o">=</span> <span class="n">app</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">original_dir</span>
      <span class="n">application</span><span class="p">.</span><span class="nf">original_dir</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">load_rakefile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
      <span class="nb">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">add_rakelib</span><span class="p">(</span><span class="o">*</span><span class="n">files</span><span class="p">)</span>
      <span class="n">application</span><span class="p">.</span><span class="nf">options</span><span class="p">.</span><span class="nf">rakelib</span> <span class="o">||=</span> <span class="p">[]</span>
      <span class="n">files</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">file</span><span class="o">|</span>
        <span class="n">application</span><span class="p">.</span><span class="nf">options</span><span class="p">.</span><span class="nf">rakelib</span> <span class="o">&lt;&lt;</span> <span class="n">file</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I think this looks <em>much</em> nicer. We see that the two main parts of Rake are the <strong>application</strong> (the CLI runner) and the <strong>tasks</strong>. We also see that Rake maintains Windows compatibility. Lastly, by inlining <a href="https://github.com/ruby/rake/blob/8cc7349ffbdf97345e5da15e1a05058c6dbcefec/lib/rake/rake_module.rb">rake/rake_module.rb</a> like this, we also immediately see the main entry point to Rake, which is useful if we’re developing a 3rd-party gem which integrates with Rake.</p>

<h2 id="conclusion">Conclusion</h2>

<p>If each file only requires the dependencies it needs, the code is easier to read and maintain. Every library can list the <em>main</em> components of the libary in its primary file, and then each component in turn can require its own dependencies. This way we get a nice logical tree structure which we can easily follow. Try applying it to your code, and you will start to understand your code better.</p>

  </div>
</article>

<div class="mt-8 md:mt-10">
  
  <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'twinblog'; // required: replace example with your forum shortname
    var disqus_identifier = '/require-only-what-you-require';
    var disqus_url = 'https://janko.io/require-only-what-you-require/';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



</div>

      </main>
    </div>

    
      <script>
  // Gauges
  var _gauges = _gauges || [];
  (function() {
    var t   = document.createElement('script');
    t.type  = 'text/javascript';
    t.async = true;
    t.id    = 'gauges-tracker';
    t.setAttribute('data-site-id', '51f5bd47f5a1f545ac0000fc');
    t.src = '//secure.gaug.es/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>

    
  </body>
</html>
